<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wing&#39;s Blog</title>
  
  <subtitle>Technology to Change the World</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ruanyandong.github.io/"/>
  <updated>2020-03-09T15:20:33.751Z</updated>
  <id>https://ruanyandong.github.io/</id>
  
  <author>
    <name>阮严冬——Wings</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一千万个数高效求和</title>
    <link href="https://ruanyandong.github.io/2020/03/09/%E4%B8%80%E5%8D%83%E4%B8%87%E4%B8%AA%E6%95%B0%E9%AB%98%E6%95%88%E6%B1%82%E5%92%8C/"/>
    <id>https://ruanyandong.github.io/2020/03/09/一千万个数高效求和/</id>
    <published>2020-03-09T15:20:03.000Z</published>
    <updated>2020-03-09T15:20:33.751Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p><strong>“一千万个数如何高效求和？”</strong>，当看到这个问题的时候，第一反应就是分段求和再相加，而JDK1.8提供的LongAdder类，就是通过<strong>分段求和再汇总</strong>的思想设计的。为了对比实践，我们先用单线程直接求和，然后再使用多线程求和。</p><h1 id="单线程求和"><a href="#单线程求和" class="headerlink" title="单线程求和"></a>单线程求和</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单线程直接求和</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">singleThreadSum</span><span class="params">(List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Integer num:list) &#123;</span><br><span class="line">            sum+=num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"单线程总和——&gt;"</span>+sum+<span class="string">" 耗时——&gt;"</span>+((endTime-startTime))+<span class="string">"毫秒"</span>);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="多线程求和"><a href="#多线程求和" class="headerlink" title="多线程求和"></a>多线程求和</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一千万个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TOTAL_NUMBER = <span class="number">10000000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每个task求和的规模</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE_PER_TASK = <span class="number">200000</span>;</span><br><span class="line">    <span class="comment">// 线程池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadPoolExecutor executor = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 核心线程数 CPU数量 + 1</span></span><br><span class="line">        <span class="keyword">int</span> corePoolSize = Runtime.getRuntime().availableProcessors() + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxPoolSize = corePoolSize*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        executor = <span class="keyword">new</span> ThreadPoolExecutor(corePoolSize, maxPoolSize, <span class="number">3</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LogAdder多线程求和</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">multiThreadLongAdderSum</span><span class="params">(List&lt;Integer&gt; list)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        LongAdder longAdder = <span class="keyword">new</span> LongAdder();</span><br><span class="line">        <span class="comment">//拆分任务</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; resultList = split(list,SIZE_PER_TASK);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> taskSize = resultList.size();</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(taskSize);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; taskSize; i++) &#123;</span><br><span class="line">            List&lt;Integer&gt; subList = resultList.get(i);</span><br><span class="line">            executor.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> num : subList) &#123;</span><br><span class="line">                        <span class="comment">// 把每个task中的数字累加</span></span><br><span class="line">                       longAdder.add(num);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// task执行完成后，计数器减一</span></span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 主线程等待所有子线程执行完成</span></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"LongAdder多线程总和——&gt;"</span>+longAdder.intValue()+<span class="string">" 耗时——&gt;"</span>+((endTime-startTime))+<span class="string">"毫秒"</span>);</span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">        <span class="keyword">return</span> longAdder.intValue();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多线程求和</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">multiThreadSum</span><span class="params">(List&lt;Integer&gt; list)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//拆分任务</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; resultList = split(list,SIZE_PER_TASK);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> taskSize = resultList.size();</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(taskSize);</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[taskSize];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; taskSize; i++) &#123;</span><br><span class="line">            List&lt;Integer&gt; subList = resultList.get(i);</span><br><span class="line">            <span class="keyword">int</span> index = i;</span><br><span class="line">            executor.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> num : subList) &#123;</span><br><span class="line">                        <span class="comment">// 把每个task中的数字累加</span></span><br><span class="line">                        result[index]+=num;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// task执行完成后，计数器减一</span></span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 主线程等待所有子线程执行完成</span></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> per:result) &#123;</span><br><span class="line">            sum += per;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"多线程总和——&gt;"</span>+sum+<span class="string">" 耗时——&gt;"</span>+((endTime-startTime))+<span class="string">"毫秒"</span>);</span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分割列表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;List&lt;Integer&gt;&gt; split(List&lt;Integer&gt; rawList, <span class="keyword">int</span> perSize)&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; resultList = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; TOTAL_NUMBER ; i = i+SIZE_PER_TASK) &#123;</span><br><span class="line">            List&lt;Integer&gt; list = rawList.subList(i,i+SIZE_PER_TASK);</span><br><span class="line">            resultList.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"分割好的list-&gt;"</span>+resultList.size());</span><br><span class="line">        <span class="keyword">return</span> resultList;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; TOTAL_NUMBER; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = random.nextInt(<span class="number">10</span>);</span><br><span class="line">            list.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  单线程执行</span></span><br><span class="line">        singleThreadSum(list);</span><br><span class="line">        <span class="comment">//  LongAdder多线程直接求和</span></span><br><span class="line">        multiThreadLongAdderSum(list);</span><br><span class="line">        <span class="comment">// 多线程直接求和</span></span><br><span class="line">        multiThreadSum(list);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">单线程总和——&gt;<span class="number">45006860</span> 耗时——&gt;<span class="number">24</span>毫秒</span><br><span class="line">LongAdder多线程总和——&gt;<span class="number">45006860</span> 耗时——&gt;<span class="number">251</span>毫秒</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">单线程总和——&gt;<span class="number">45001009</span> 耗时——&gt;<span class="number">19</span>毫秒</span><br><span class="line">多线程总和——&gt;<span class="number">45001009</span> 耗时——&gt;<span class="number">120</span>毫秒</span><br></pre></td></tr></table></figure><p>结果有点出乎意料，单线程比多线程花费时间更少。</p><h1 id="JDK1-8的stream"><a href="#JDK1-8的stream" class="headerlink" title="JDK1.8的stream"></a>JDK1.8的stream</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JDK1.8的stream</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">streamSum</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">int</span> sum = list.stream().mapToInt(num -&gt; num).sum();</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.printf(<span class="string">"stream方式计算结果：%d, 耗时：%d 毫秒"</span>,sum, (end - start));</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">单线程总和——&gt;<span class="number">45011698</span> 耗时——&gt;<span class="number">19</span>毫秒</span><br><span class="line">多线程总和——&gt;<span class="number">45011698</span> 耗时——&gt;<span class="number">130</span>毫秒</span><br><span class="line">stream方式计算结果：<span class="number">45011698</span>, 耗时：<span class="number">24</span> 毫秒</span><br></pre></td></tr></table></figure><h1 id="JDK1-8的-parallelStream方式"><a href="#JDK1-8的-parallelStream方式" class="headerlink" title="JDK1.8的 parallelStream方式"></a>JDK1.8的 parallelStream方式</h1><p>parallelStream见名知意，就是并行的stream。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JDK1.8的parallelStream方式</span></span><br><span class="line">    <span class="comment">//parallelStream见名知意，就是并行的stream。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parallelStreamSum</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">int</span> sum = list.parallelStream().mapToInt(num -&gt; num).sum();</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.printf(<span class="string">"parallel stream方式计算结果：%d, 耗时：%d 毫秒"</span>,sum, (end - start));</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">单线程总和——&gt;<span class="number">45016893</span> 耗时——&gt;<span class="number">17</span>毫秒</span><br><span class="line">多线程总和——&gt;<span class="number">45016893</span> 耗时——&gt;<span class="number">112</span>毫秒</span><br><span class="line">stream方式计算结果：<span class="number">45016893</span>, 耗时：<span class="number">23</span> 毫秒</span><br><span class="line">parallel stream方式计算结果：<span class="number">45016893</span>, 耗时：<span class="number">28</span> 毫秒</span><br></pre></td></tr></table></figure></p><h1 id="ForkJoin方式"><a href="#ForkJoin方式" class="headerlink" title="ForkJoin方式"></a>ForkJoin方式</h1><p>ForkJoin框架是JDK1.7提出的，用于拆分任务计算再合并计算结果的框架。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当我们需要执行大量的小任务时，有经验的Java开发人员都会采用线程池来高效执行这些小任务。然而，有一种任务，例如，对超过<span class="number">1000</span>万个元素的数组进行排序，这种任务本身可以并发执行，但如何拆解成小任务需要在任务执行的过程中动态拆分。这样，大任务可以拆成小任务，小任务还可以继续拆成更小的任务，最后把任务的结果汇总合并，得到最终结果，这种模型就是Fork/Join模型。</span><br></pre></td></tr></table></figure><p>ForkJoin框架的使用大致分为两个部分：实现ForkJoin任务、执行任务</p><ul><li>实现ForkJoin任务<br>自定义类继承RecursiveTask（有返回值）或者RecursiveAction（无返回值），实现compute方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态内部类的方式实现</span></span><br><span class="line"><span class="comment">     * forkjoin任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SicForkJoinTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 子任务计算区间开始</span></span><br><span class="line">        <span class="keyword">private</span> Integer left;</span><br><span class="line">        <span class="comment">// 子任务计算区间结束</span></span><br><span class="line">        <span class="keyword">private</span> Integer right;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (right - left &lt; SIZE_PER_TASK) &#123;</span><br><span class="line">                <span class="comment">// 任务足够小时，直接计算</span></span><br><span class="line">                <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt; right; i++) &#123;</span><br><span class="line">                    sum += arr[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> sum;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 继续拆分任务</span></span><br><span class="line">            <span class="keyword">int</span> middle = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            SicForkJoinTask leftTask = <span class="keyword">new</span> SicForkJoinTask(arr, left, middle);</span><br><span class="line">            SicForkJoinTask rightTask = <span class="keyword">new</span> SicForkJoinTask(arr, middle, right);</span><br><span class="line">            invokeAll(leftTask, rightTask);</span><br><span class="line">            Integer leftResult = leftTask.join();</span><br><span class="line">            Integer rightResult = rightTask.join();</span><br><span class="line">            <span class="keyword">return</span> leftResult + rightResult;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SicForkJoinTask</span><span class="params">(<span class="keyword">int</span>[] arr, Integer left, Integer right)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.arr = arr;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>执行任务<br>通过ForkJoinPool的invoke方法执行ForkJoin任务<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ForkJoin线程池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">forkJoinSum</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 执行ForkJoin任务</span></span><br><span class="line">    Integer sum = forkJoinPool.invoke(<span class="keyword">new</span> SicForkJoinTask(arr, <span class="number">0</span>, TOTAL_NUMBER));</span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    System.out.printf(<span class="string">"\nforkjoin方式计算结果:%d, 耗时：%d 毫秒"</span>, sum, (end - start));</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">单线程总和——&gt;<span class="number">44994415</span> 耗时——&gt;<span class="number">17</span>毫秒</span><br><span class="line">多线程总和——&gt;<span class="number">44994415</span> 耗时——&gt;<span class="number">132</span>毫秒</span><br><span class="line">stream方式计算结果：<span class="number">44994415</span>, 耗时：<span class="number">22</span> 毫秒</span><br><span class="line">parallel stream方式计算结果：<span class="number">44994415</span>, 耗时：<span class="number">30</span> 毫秒</span><br><span class="line">forkjoin方式计算结果:<span class="number">44994415</span>, 耗时：<span class="number">174</span> 毫秒</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;“一千万个数如何高效求和？”&lt;/strong&gt;，当看到这个问题的时候，第一反应就是分段求和再相加，而JDK1.8提供的Lon
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CountDownLatch详解</title>
    <link href="https://ruanyandong.github.io/2020/03/09/CountDownLatch%E8%AF%A6%E8%A7%A3/"/>
    <id>https://ruanyandong.github.io/2020/03/09/CountDownLatch详解/</id>
    <published>2020-03-09T15:18:14.000Z</published>
    <updated>2020-03-09T15:18:40.379Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul><li>CountDownLatch中count down是倒数的意思，在构造CountDownLatch的时候需要传入一个整数n，在这个整数“倒数”到0之前，主线程需要等待，而这个“倒数”过程则是由各个执行线程驱动的，每个线程执行完一个任务“倒数”一次。</li><li>总结来说，CountDownLatch的作用就是等待其他的线程都执行完任务，必要时可以对各个任务的执行结果进行汇总，然后主线程才继续往下执行。</li><li>CountDownLatch主要有两个方法：countDown()和await()。countDown()方法用于使计数器减一，其一般是执行任务的线程调用，await()方法则使调用该方法的线程处于等待状态，其一般是主线程调用。</li><li>需要注意的是，countDown()方法并没有规定一个线程只能调用一次，当同一个线程调用多次countDown()方法时，每次都会使计数器减一；另外，await()方法也并没有规定只能有一个线程执行该方法，如果多个线程同时执行await()方法，那么这几个线程都将处于等待状态，并且以共享模式享有同一个锁<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1></li><li>CountDownLatch非常适合于对任务进行拆分，使其并行执行，比如某个任务执行2s，其对数据的请求可以分为五个部分，那么就可以将这个任务拆分为5个子任务，分别交由五个线程执行，执行完成之后再由主线程进行汇总，此时，总的执行时间将决定于执行最慢的任务，平均来看，还是大大减少了总的执行时间。</li><li>另外一种比较合适使用CountDownLatch的地方是使用某些外部链接请求数据的时候。比如图片，我们使用的图片服务只提供了获取单个图片的功能，而每次获取图片的时间不等，一般都需要1.5s~2s。当我们需要批量获取图片的时候，比如列表页需要展示一系列的图片，如果使用单个线程顺序获取，那么等待时间将会极长，此时我们就可以使用CountDownLatch对获取图片的操作进行拆分，并行的获取图片，这样也就缩短了总的获取时间。<h1 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h1></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">5</span>);</span><br><span class="line">        Service service = <span class="keyword">new</span> Service(latch);</span><br><span class="line">        Runnable task = () -&gt; service.exec();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(task);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"main thread await. "</span>);</span><br><span class="line">        latch.await();</span><br><span class="line">        System.out.println(<span class="string">"main thread finishes await. "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch latch;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Service</span><span class="params">(CountDownLatch latch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.latch = latch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" execute task. "</span>);</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" finished task. "</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">int</span> seconds)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(seconds);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，首先声明了一个CountDownLatch对象，并且由主线程创建了5个线程，分别执行任务，在每个任务中，当前线程会休眠2秒。在启动线程之后，主线程调用了CountDownLatch.await()方法，此时，主线程将在此处等待创建的5个线程执行完任务之后才继续往下执行。如下是执行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">0</span> execute task. </span><br><span class="line">Thread-<span class="number">1</span> execute task. </span><br><span class="line">Thread-<span class="number">2</span> execute task. </span><br><span class="line">Thread-<span class="number">3</span> execute task. </span><br><span class="line">main thread await. </span><br><span class="line">Thread-<span class="number">4</span> execute task. </span><br><span class="line">Thread-<span class="number">0</span> finished task. </span><br><span class="line">Thread-<span class="number">2</span> finished task. </span><br><span class="line">Thread-<span class="number">1</span> finished task. </span><br><span class="line">Thread-<span class="number">3</span> finished task. </span><br><span class="line">Thread-<span class="number">4</span> finished task. </span><br><span class="line">main thread finishes await.</span><br></pre></td></tr></table></figure><p>从输出结果可以看出，主线程先启动了五个线程，然后主线程进入等待状态，当这五个线程都执行完任务之后主线程才结束了等待。上述代码中需要注意的是，在执行任务的线程中，使用了try…finally结构，该结构可以保证创建的线程发生异常时CountDownLatch.countDown()方法也会执行，也就保证了主线程不会一直处于等待状态。</p><h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><p>CountDownLatch是基于AbstractQueuedSynchronizer实现的，在AbstractQueuedSynchronizer中维护了一个volatile类型的整数state，volatile可以保证多线程环境下该变量的修改对每个线程都可见，并且由于该属性为整型，因而对该变量的修改也是原子的。创建一个CountDownLatch对象时，所传入的整数n就会赋值给state属性，当countDown()方法调用时，该线程就会尝试对state减一，而调用await()方法时，当前线程就会判断state属性是否为0，如果为0，则继续往下执行，如果不为0，则使当前线程进入等待状态，直到某个线程将state属性置为0，其就会唤醒在await()方法中等待的线程。如下是countDown()方法的源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   这里sync也即一个继承了AbstractQueuedSynchronizer的类实例，该类是CountDownLatch的一个内部类，其声明如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4982264981922014374L</span>;</span><br><span class="line"></span><br><span class="line">  Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">    setState(count);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getState();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="keyword">int</span> c = getState();   <span class="comment">// 获取当前state属性的值</span></span><br><span class="line">      <span class="keyword">if</span> (c == <span class="number">0</span>)   <span class="comment">// 如果state为0，则说明当前计数器已经计数完成，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (compareAndSetState(c, nextc)) <span class="comment">// 使用CAS算法对state进行设置</span></span><br><span class="line">        <span class="keyword">return</span> nextc == <span class="number">0</span>;  <span class="comment">// 设置成功后返回当前是否为最后一个设置state的线程</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这里tryReleaseShared(int)方法即对state属性进行减一操作的代码。可以看到，CAS也即compare and set的缩写，jvm会保证该方法的原子性，其会比较state是否为c，如果是则将其设置为nextc（自减1），如果state不为c，则说明有另外的线程在getState()方法和compareAndSetState()方法调用之间对state进行了设置，当前线程也就没有成功设置state属性的值，其会进入下一次循环中，如此往复，直至其成功设置state属性的值，即countDown()方法调用成功。</p><p> 在countDown()方法中调用的sync.releaseShared(1)调用时实际还是调用的tryReleaseShared(int)方法，如下是releaseShared(int)方法的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">    doReleaseShared();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在执行sync.releaseShared(1)方法时，其在调用tryReleaseShared(int)方法时会在无限for循环中设置state属性的值，设置成功之后其会根据设置的返回值（此时state已经自减了一），即当前线程是否为将state属性设置为0的线程，来判断是否执行if块中的代码。doReleaseShared()方法主要作用是唤醒调用了await()方法的线程。需要注意的是，如果有多个线程调用了await()方法，这些线程都是以共享的方式等待在await()方法处的，试想，如果以独占的方式等待，那么当计数器减少至零时，就只有一个线程会被唤醒执行await()之后的代码，这显然不符合逻辑。如下是doReleaseShared()方法的实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    Node h = head;  <span class="comment">// 记录等待队列中的头结点的线程</span></span><br><span class="line">    <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;   <span class="comment">// 头结点不为空，且头结点不等于尾节点</span></span><br><span class="line">      <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">      <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;  <span class="comment">// SIGNAL状态表示当前节点正在等待被唤醒</span></span><br><span class="line">        <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))    <span class="comment">// 清除当前节点的等待状态</span></span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        unparkSuccessor(h); <span class="comment">// 唤醒当前节点的下一个节点</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp; !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (h == head)  <span class="comment">// 如果h还是指向头结点，说明前面这段代码执行过程中没有其他线程对头结点进行过处理</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 在doReleaseShared()方法中（始终注意当前方法是最后一个执行countDown()方法的线程执行的），首先判断头结点不为空，且不为尾节点，说明等待队列中有等待唤醒的线程，这里需要说明的是，在等待队列中，头节点中并没有保存正在等待的线程，其只是一个空的Node对象，真正等待的线程是从头节点的下一个节点开始存放的，因而会有对头结点是否等于尾节点的判断。在判断等待队列中有正在等待的线程之后，其会清除头结点的状态信息，并且调用unparkSuccessor(Node)方法唤醒头结点的下一个节点，使其继续往下执行。如下是unparkSuccessor(Node)方法的具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">  <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">    compareAndSetWaitStatus(node, ws, <span class="number">0</span>);   <span class="comment">// 清除当前节点的等待状态</span></span><br><span class="line"></span><br><span class="line">  Node s = node.next;</span><br><span class="line">  <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;  <span class="comment">// s的等待状态大于0说明该节点中的线程已经被外部取消等待了</span></span><br><span class="line">    s = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 从队列尾部往前遍历，找到最后一个处于等待状态的节点，用s记录下来</span></span><br><span class="line">    <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">      <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">        s = t;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">    LockSupport.unpark(s.thread);   <span class="comment">// 唤醒离传入节点最近的处于等待状态的节点线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  可以看到，unparkSuccessor(Node)方法的作用是唤醒离传入节点最近的一个处于等待状态的线程，使其继续往下执行。前面我们讲到过，等待队列中的线程可能有多个，而调用countDown()方法的线程只唤醒了一个处于等待状态的线程，这里剩下的等待线程是如何被唤醒的呢？其实这些线程是被当前唤醒的线程唤醒的。具体的我们可以看看await()方法的具体执行过程。如下是await()方法的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">        await()方法实际还是调用了Sync对象的方法acquireSharedInterruptibly(<span class="keyword">int</span>)方法，如下是该方法的具体实现：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">  <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">    doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到acquireSharedInterruptibly(int)方法判断当前线程是否需要以共享状态获取执行权限，这里tryAcquireShared(int)方法是AbstractQueuedSynchronizer中的一个模板方法，其具体实现在前面的Sync类中，可以看到，其主要是判断state是否为零，如果为零则返回1，表示当前线程不需要进行权限获取，可直接执行后续代码，返回-1则表示当前线程需要进行共享权限。具体的获取执行权限的代码在doAcquireSharedInterruptibly(int)方法中，如下是该方法的具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Node node = addWaiter(Node.SHARED); <span class="comment">// 使用当前线程创建一个共享模式的节点</span></span><br><span class="line">  <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="keyword">final</span> Node p = node.predecessor();    <span class="comment">// 获取当前节点的前一个节点</span></span><br><span class="line">      <span class="keyword">if</span> (p == head) &#123;  <span class="comment">// 判断前一个节点是否为头结点</span></span><br><span class="line">        <span class="keyword">int</span> r = tryAcquireShared(arg);  <span class="comment">// 查看当前线程是否获取到了执行权限</span></span><br><span class="line">        <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;   <span class="comment">// 大于0表示获取了执行权限</span></span><br><span class="line">          setHeadAndPropagate(node, r); <span class="comment">// 将当前节点设置为头结点，并且唤醒后面处于等待状态的节点</span></span><br><span class="line">          p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">          failed = <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 走到这一步说明没有获取到执行权限，就使当前线程进入“搁置”状态</span></span><br><span class="line">      <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">          parkAndCheckInterrupt())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (failed)</span><br><span class="line">      cancelAcquire(node);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 在doAcquireSharedInterruptibly(int)方法中，首先使用当前线程创建一个共享模式的节点。然后在一个for循环中判断当前线程是否获取到执行权限，如果有（r &gt;= 0判断）则将当前节点设置为头节点，并且唤醒后续处于共享模式的节点；如果没有，则对调用shouldParkAfterFailedAcquire(Node, Node)和parkAndCheckInterrupt()方法使当前线程处于“搁置”状态，该“搁置”状态是由操作系统进行的，这样可以避免该线程无限循环而获取不到执行权限，造成资源浪费，这里也就是线程处于等待状态的位置，也就是说当线程被阻塞的时候就是阻塞在这个位置。当有多个线程调用await()方法而进入等待状态时，这几个线程都将等待在此处。这里回过头来看前面将的countDown()方法，其会唤醒处于等待队列中离头节点最近的一个处于等待状态的线程，也就是说该线程被唤醒之后会继续从这个位置开始往下执行，此时执行到tryAcquireShared(int)方法时，发现r大于0（因为state已经被置为0了），该线程就会调用setHeadAndPropagate(Node, int)方法，并且退出当前循环，也就开始执行awat()方法之后的代码。这里我们看看setHeadAndPropagate(Node, int)方法的具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">  Node h = head;</span><br><span class="line">  setHead(node);    <span class="comment">// 将当前节点设置为头节点</span></span><br><span class="line">  <span class="comment">// 检查唤醒过程是否需要往下传递，并且检查头结点的等待状态</span></span><br><span class="line">  <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">      (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())  <span class="comment">// 如果下一个节点是尝试以共享状态获取获取执行权限的节点，则将其唤醒</span></span><br><span class="line">      doReleaseShared();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> setHeadAndPropagate(Node, int)方法主要作用是设置当前节点为头结点，并且将唤醒工作往下传递，在传递的过程中，其会判断被传递的节点是否是以共享模式尝试获取执行权限的，如果不是，则传递到该节点处为止（一般情况下，等待队列中都只会都是处于共享模式或者处于独占模式的节点）。也就是说，头结点会依次唤醒后续处于共享状态的节点，这也就是共享锁与独占锁的实现方式。这里doReleaseShared()方法也就是我们前面讲到的会将离头结点最近的一个处于等待状态的节点唤醒的方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;CountDownLatch中count down是倒数的意思，在构造CountDownLatch的时候需要传入一个整数n，在这
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>求解连续子数组的最大和</title>
    <link href="https://ruanyandong.github.io/2020/03/09/%E6%B1%82%E8%A7%A3%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/"/>
    <id>https://ruanyandong.github.io/2020/03/09/求解连续子数组的最大和/</id>
    <published>2020-03-09T15:15:18.000Z</published>
    <updated>2020-03-09T15:16:38.727Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><ul><li><p>题目：输入一个整型数组，数组里有正数也有负数。数组中一个或连续的多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O(n)。</p></li><li><p>例子说明：例如输入的数组为{1, -2, 3, 10, -4, 7, 2, -5}，和最大的子数组为｛3, 10, -4, 7, 2}。因此输出为该子数组的和18 。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findBiggestSumOfSubArray</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录最大的子数组和，开始时是最小的整数</span></span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="comment">//当前的和</span></span><br><span class="line">        <span class="keyword">int</span> currentSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> per:array) &#123;</span><br><span class="line">            <span class="comment">// 如果当前和小于等于0，重置当前和</span></span><br><span class="line">            <span class="keyword">if</span> (currentSum &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                currentSum = per;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果当前和大于0，累加当前和</span></span><br><span class="line">                currentSum = currentSum + per;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 记录当前的最大子数组和</span></span><br><span class="line">            <span class="keyword">if</span> (currentSum &gt; max)&#123;</span><br><span class="line">                max = currentSum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] data = &#123;<span class="number">1</span>, -<span class="number">2</span>, <span class="number">3</span>, <span class="number">10</span>, -<span class="number">4</span>, <span class="number">7</span>, <span class="number">2</span>, -<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] data2 = &#123;-<span class="number">2</span>, -<span class="number">8</span>, -<span class="number">1</span>, -<span class="number">5</span>, -<span class="number">9</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] data3 = &#123;<span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        System.out.println(findBiggestSumOfSubArray(data));</span><br><span class="line">        System.out.println(findBiggestSumOfSubArray(data2));</span><br><span class="line">        System.out.println(findBiggestSumOfSubArray(data3));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"D:\IntelliJ IDEA 2019.3.1\jbr\bin\java.exe"</span> <span class="string">"-javaagent:D:\IntelliJ IDEA 2019.3.1\lib\idea_rt.jar=63150:D:\IntelliJ IDEA 2019.3.1\bin"</span> -Dfile.encoding=UTF-<span class="number">8</span> -classpath D:\IdeaProject\Reflect\out\production\Reflect com.ai.ReflectTest</span><br><span class="line"><span class="number">18</span></span><br><span class="line">-<span class="number">1</span></span><br><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/DERRANTCM/article/details/46736967" target="_blank" rel="noopener">连续子数组的最大和</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;题目：输入一个整型数组，数组里有正数也有负数。数组中一个或连续的多个整数组成一个子数组。求所有子数组的和的最大值。要求时间
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java并发编程-原子性变量</title>
    <link href="https://ruanyandong.github.io/2020/03/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8F%98%E9%87%8F/"/>
    <id>https://ruanyandong.github.io/2020/03/01/Java并发编程-原子性变量/</id>
    <published>2020-03-01T14:48:11.000Z</published>
    <updated>2020-03-01T14:52:25.021Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原子性布尔-AtomicBoolean"><a href="#原子性布尔-AtomicBoolean" class="headerlink" title="原子性布尔 AtomicBoolean"></a>原子性布尔 AtomicBoolean</h1><p>AtomicBoolean 类为我们提供了一个可以用原子方式进行读和写的布尔值，它还拥有一些先进的原子性操作，比如 compareAndSet()。AtomicBoolean 类位于 java.util.concurrent.atomic 包，完整类名是为 java.util.concurrent.atomic.AtomicBoolean。</p><h5 id="1、创建一个-AtomicBoolean"><a href="#1、创建一个-AtomicBoolean" class="headerlink" title="1、创建一个 AtomicBoolean"></a>1、创建一个 AtomicBoolean</h5><p>你可以这样创建一个 AtomicBoolean：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AtomicBoolean atomicBoolean = <span class="keyword">new</span> AtomicBoolean();</span><br></pre></td></tr></table></figure></p><p>以上示例新建了一个默认值为 false 的 AtomicBoolean。如果你想要为 AtomicBoolean 实例设置一个显式的初始值，那么你可以将初始值传给 AtomicBoolean 的构造子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AtomicBoolean atomicBoolean = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure></p><h5 id="2、获取-AtomicBoolean-的值"><a href="#2、获取-AtomicBoolean-的值" class="headerlink" title="2、获取 AtomicBoolean 的值"></a>2、获取 AtomicBoolean 的值</h5><p>你可以通过使用 get() 方法来获取一个 AtomicBoolean 的值。示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AtomicBoolean atomicBoolean = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">true</span>);  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">boolean</span> value = atomicBoolean.get();</span><br></pre></td></tr></table></figure><p>以上代码执行后 value 变量的值将为 true。</p><h5 id="3、设置-AtomicBoolean-的值"><a href="#3、设置-AtomicBoolean-的值" class="headerlink" title="3、设置 AtomicBoolean 的值"></a>3、设置 AtomicBoolean 的值</h5><p>你可以通过使用 set() 方法来设置一个 AtomicBoolean 的值。<br>示例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AtomicBoolean atomicBoolean = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">true</span>);  </span><br><span class="line">  </span><br><span class="line">atomicBoolean.set(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure></p><p>以上代码执行后 AtomicBoolean 的值为 false。</p><h5 id="4、交换-AtomicBoolean-的值"><a href="#4、交换-AtomicBoolean-的值" class="headerlink" title="4、交换 AtomicBoolean 的值"></a>4、交换 AtomicBoolean 的值</h5><p>你可以通过 getAndSet() 方法来交换一个 AtomicBoolean 实例的值。getAndSet() 方法将返回 AtomicBoolean 当前的值，并将为 AtomicBoolean 设置一个新值。示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AtomicBoolean atomicBoolean = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">true</span>);  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">boolean</span> oldValue = atomicBoolean.getAndSet(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>以上代码执行后 oldValue 变量的值为 true，atomicBoolean 实例将持有 false 值。代码成功将 AtomicBoolean 当前值 ture 交换为 false。</p><h5 id="5、比较并设置-AtomicBoolean-的值"><a href="#5、比较并设置-AtomicBoolean-的值" class="headerlink" title="5、比较并设置 AtomicBoolean 的值"></a>5、比较并设置 AtomicBoolean 的值</h5><p>compareAndSet() 方法允许你对 AtomicBoolean 的当前值与一个期望值进行比较，如果当前值等于期望值的话，将会对 AtomicBoolean 设定一个新值。compareAndSet() 方法是原子性的，因此在同一时间之内有单个线程执行它。因此 compareAndSet() 方法可被用于一些类似于锁的同步的简单实现。以下是一个 compareAndSet() 示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AtomicBoolean atomicBoolean = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">true</span>);  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">boolean</span> expectedValue = <span class="keyword">true</span>;  </span><br><span class="line"><span class="keyword">boolean</span> newValue      = <span class="keyword">false</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">boolean</span> wasNewValueSet = atomicBoolean.compareAndSet(  </span><br><span class="line">    expectedValue, newValue);</span><br></pre></td></tr></table></figure><p>本示例对 AtomicBoolean 的当前值与 true 值进行比较，如果相等，将 AtomicBoolean 的值更新为 false。</p><h1 id="原子性整型-AtomicInteger"><a href="#原子性整型-AtomicInteger" class="headerlink" title="原子性整型 AtomicInteger"></a>原子性整型 AtomicInteger</h1><p>AtomicInteger 类为我们提供了一个可以进行原子性读和写操作的 int 变量，它还包含一系列先进的原子性操作，比如 compareAndSet()。AtomicInteger 类位于 java.util.concurrent.atomic 包，因此其完整类名为 java.util.concurrent.atomic.AtomicInteger。</p><h5 id="1、创建一个-AtomicInteger"><a href="#1、创建一个-AtomicInteger" class="headerlink" title="1、创建一个 AtomicInteger"></a>1、创建一个 AtomicInteger</h5><p>创建一个 AtomicInteger 示例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();</span><br></pre></td></tr></table></figure></p><p>本示例将创建一个初始值为 0 的 AtomicInteger。如果你想要创建一个给定初始值的 AtomicInteger，你可以这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">123</span>);</span><br></pre></td></tr></table></figure></p><p>本示例将 123 作为参数传给 AtomicInteger 的构造子，它将设置 AtomicInteger 实例的初始值为 123。</p><h5 id="2、获取-AtomicInteger-的值"><a href="#2、获取-AtomicInteger-的值" class="headerlink" title="2、获取 AtomicInteger 的值"></a>2、获取 AtomicInteger 的值</h5><p>你可以使用 get() 方法获取 AtomicInteger 实例的值。示例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">123</span>);  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> theValue = atomicInteger.get();</span><br></pre></td></tr></table></figure></p><h5 id="3、设置-AtomicInteger-的值"><a href="#3、设置-AtomicInteger-的值" class="headerlink" title="3、设置 AtomicInteger 的值"></a>3、设置 AtomicInteger 的值</h5><p>你可以通过 set() 方法对 AtomicInteger 的值进行重新设置。以下是 AtomicInteger.set() 示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">123</span>);  </span><br><span class="line">  </span><br><span class="line">atomicInteger.set(<span class="number">234</span>);</span><br></pre></td></tr></table></figure><p>以上示例创建了一个初始值为 123 的 AtomicInteger，而在第二行将其值更新为 234。</p><h5 id="4、比较并设置-AtomicInteger-的值"><a href="#4、比较并设置-AtomicInteger-的值" class="headerlink" title="4、比较并设置 AtomicInteger 的值"></a>4、比较并设置 AtomicInteger 的值</h5><p>AtomicInteger 类也通过了一个原子性的 compareAndSet() 方法。这一方法将 AtomicInteger 实例的当前值与期望值进行比较，如果二者相等，为 AtomicInteger 实例设置一个新值。AtomicInteger.compareAndSet() 代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">123</span>);  </span><br><span class="line"><span class="keyword">int</span> expectedValue = <span class="number">123</span>;  </span><br><span class="line"><span class="keyword">int</span> newValue      = <span class="number">234</span>;  </span><br><span class="line">atomicInteger.compareAndSet(expectedValue, newValue);</span><br></pre></td></tr></table></figure><p>本示例首先新建一个初始值为 123 的 AtomicInteger 实例。然后将 AtomicInteger 与期望值 123 进行比较，如果相等，将 AtomicInteger 的值更新为 234。</p><h5 id="5、增加-AtomicInteger-值"><a href="#5、增加-AtomicInteger-值" class="headerlink" title="5、增加 AtomicInteger 值"></a>5、增加 AtomicInteger 值</h5><p>AtomicInteger 类包含有一些方法，通过它们你可以增加 AtomicInteger 的值，并获取其值。这些方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">addAndGet()</span><br><span class="line">getAndAdd()</span><br><span class="line">getAndIncrement()</span><br><span class="line">incrementAndGet()</span><br></pre></td></tr></table></figure></p><p>第一个 addAndGet() 方法给 AtomicInteger 增加了一个值，然后返回增加后的值。getAndAdd() 方法为 AtomicInteger 增加了一个值，但返回的是增加以前的 AtomicInteger 的值。具体使用哪一个取决于你的应用场景。以下是这两种方法的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();  </span><br><span class="line">System.out.println(atomicInteger.getAndAdd(<span class="number">10</span>));  </span><br><span class="line">System.out.println(atomicInteger.addAndGet(<span class="number">10</span>));</span><br></pre></td></tr></table></figure><p>本示例将打印出 0 和 20。例子中，第二行拿到的是加 10 之前的 AtomicInteger 的值。加 10 之前的值是 0。第三行将 AtomicInteger 的值再加 10，并返回加操作之后的值。该值现在是为 20。你当然也可以使用这俩方法为 AtomicInteger 添加负值。结果实际是一个减法操作。getAndIncrement() 和 incrementAndGet() 方法类似于 getAndAdd() 和 addAndGet()，但每次只将 AtomicInteger 的值加 1。</p><h5 id="6、减小-AtomicInteger-的值"><a href="#6、减小-AtomicInteger-的值" class="headerlink" title="6、减小 AtomicInteger 的值"></a>6、减小 AtomicInteger 的值</h5><p>AtomicInteger 类还提供了一些减小 AtomicInteger 的值的原子性方法。这些方法是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">decrementAndGet()</span><br><span class="line">getAndDecrement()</span><br></pre></td></tr></table></figure></p><p>decrementAndGet() 将 AtomicInteger 的值减一，并返回减一后的值。getAndDecrement() 也将 AtomicInteger 的值减一，但它返回的是减一之前的值。</p><h1 id="原子性长整型-AtomicLong"><a href="#原子性长整型-AtomicLong" class="headerlink" title="原子性长整型 AtomicLong"></a>原子性长整型 AtomicLong</h1><p>AtomicLong 类为我们提供了一个可以进行原子性读和写操作的 long 变量，它还包含一系列先进的原子性操作，比如 compareAndSet()。AtomicLong 类位于 java.util.concurrent.atomic 包，因此其完整类名为 java.util.concurrent.atomic.AtomicLong。</p><h5 id="1、创建一个-AtomicLong"><a href="#1、创建一个-AtomicLong" class="headerlink" title="1、创建一个 AtomicLong"></a>1、创建一个 AtomicLong</h5><p>创建一个 AtomicLong 如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AtomicLong atomicLong = <span class="keyword">new</span> AtomicLong();</span><br></pre></td></tr></table></figure></p><p>将创建一个初始值为 0 的 AtomicLong。如果你想创建一个指定初始值的 AtomicLong，可以：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AtomicLong atomicLong = <span class="keyword">new</span> AtomicLong(<span class="number">123</span>);</span><br></pre></td></tr></table></figure></p><p>本示例将 123 作为参数传递给 AtomicLong 的构造子，后者将 AtomicLong 实例的初始值设置为 123。</p><h5 id="2、获取-AtomicLong-的值"><a href="#2、获取-AtomicLong-的值" class="headerlink" title="2、获取 AtomicLong 的值"></a>2、获取 AtomicLong 的值</h5><p>你可以通过 get() 方法获取 AtomicLong 的值。AtomicLong.get() 示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AtomicLong atomicLong = <span class="keyword">new</span> AtomicLong(<span class="number">123</span>);  </span><br><span class="line"><span class="keyword">long</span> theValue = atomicLong.get();</span><br></pre></td></tr></table></figure><h5 id="3、设置-AtomicLong-的值"><a href="#3、设置-AtomicLong-的值" class="headerlink" title="3、设置 AtomicLong 的值"></a>3、设置 AtomicLong 的值</h5><p>你可以通过 set() 方法设置 AtomicLong 实例的值。一个 AtomicLong.set() 的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AtomicLong atomicLong = <span class="keyword">new</span> AtomicLong(<span class="number">123</span>);  </span><br><span class="line">atomicLong.set(<span class="number">234</span>);</span><br></pre></td></tr></table></figure><p>本示例新建了一个初始值为 123 的 AtomicLong，第二行将其值设置为 234。</p><h5 id="4、比较并设置-AtomicLong-的值"><a href="#4、比较并设置-AtomicLong-的值" class="headerlink" title="4、比较并设置 AtomicLong 的值"></a>4、比较并设置 AtomicLong 的值</h5><p>AtomicLong 类也有一个原子性的 compareAndSet() 方法。这一方法将 AtomicLong 实例的当前值与一个期望值进行比较，如果两种相等，为 AtomicLong 实例设置一个新值。AtomicLong.compareAndSet() 使用示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AtomicLong atomicLong = <span class="keyword">new</span> AtomicLong(<span class="number">123</span>);  </span><br><span class="line"><span class="keyword">long</span> expectedValue = <span class="number">123</span>;  </span><br><span class="line"><span class="keyword">long</span> newValue      = <span class="number">234</span>;  </span><br><span class="line">atomicLong.compareAndSet(expectedValue, newValue);</span><br></pre></td></tr></table></figure></p><p>本示例新建了一个初始值为 123 的 AtomicLong。然后将 AtomicLong 的当前值与期望值 123 进行比较，如果相等的话，AtomicLong 的新值将变为 234。</p><h5 id="5、增加-AtomicLong-值"><a href="#5、增加-AtomicLong-值" class="headerlink" title="5、增加 AtomicLong 值"></a>5、增加 AtomicLong 值</h5><p>AtomicLong 具备一些能够增加 AtomicLong 的值并返回自身值的方法。这些方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">addAndGet()</span><br><span class="line">getAndAdd()</span><br><span class="line">getAndIncrement()</span><br><span class="line">incrementAndGet()</span><br></pre></td></tr></table></figure></p><p>第一个方法 addAndGet() 将 AtomicLong 的值加一个数字，并返回增加后的值。第二个方法 getAndAdd() 也将 AtomicLong 的值加一个数字，但返回的是增加前的 AtomicLong 的值。具体使用哪一个取决于你自己的场景。示例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AtomicLong atomicLong = <span class="keyword">new</span> AtomicLong();  </span><br><span class="line">System.out.println(atomicLong.getAndAdd(<span class="number">10</span>));  </span><br><span class="line">System.out.println(atomicLong.addAndGet(<span class="number">10</span>));</span><br></pre></td></tr></table></figure></p><p>本示例将打印出 0 和 20。例子中，第二行拿到的是加 10 之前的 AtomicLong 的值。加 10 之前的值是 0。第三行将 AtomicLong 的值再加 10，并返回加操作之后的值。该值现在是为 20。你当然也可以使用这俩方法为 AtomicLong 添加负值。结果实际是一个减法操作。getAndIncrement() 和 incrementAndGet() 方法类似于 getAndAdd() 和 addAndGet()，但每次只将 AtomicLong 的值加 1。</p><h5 id="6、减小-AtomicLong-的值"><a href="#6、减小-AtomicLong-的值" class="headerlink" title="6、减小 AtomicLong 的值"></a>6、减小 AtomicLong 的值</h5><p>AtomicLong 类还提供了一些减小 AtomicLong 的值的原子性方法。这些方法是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">decrementAndGet()</span><br><span class="line">getAndDecrement()</span><br></pre></td></tr></table></figure></p><p>decrementAndGet() 将 AtomicLong 的值减一，并返回减一后的值。getAndDecrement() 也将 AtomicLong 的值减一，但它返回的是减一之前的值。</p><h1 id="原子性引用型-AtomicReference"><a href="#原子性引用型-AtomicReference" class="headerlink" title="原子性引用型 AtomicReference"></a>原子性引用型 AtomicReference</h1><p>AtomicReference 提供了一个可以被原子性读和写的对象引用变量。原子性的意思是多个想要改变同一个 AtomicReference 的线程不会导致 AtomicReference 处于不一致的状态。AtomicReference 还有一个 compareAndSet() 方法，通过它你可以将当前引用于一个期望值(引用)进行比较，如果相等，在该 AtomicReference 对象内部设置一个新的引用。</p><h5 id="1、创建一个-AtomicReference"><a href="#1、创建一个-AtomicReference" class="headerlink" title="1、创建一个 AtomicReference"></a>1、创建一个 AtomicReference</h5><p>创建 AtomicReference 如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AtomicReference atomicReference = <span class="keyword">new</span> AtomicReference();</span><br></pre></td></tr></table></figure></p><p>如果你需要使用一个指定引用创建 AtomicReference，可以：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String initialReference = <span class="string">"the initially referenced string"</span>;  </span><br><span class="line">AtomicReference atomicReference = <span class="keyword">new</span> AtomicReference(initialReference);</span><br></pre></td></tr></table></figure></p><h5 id="2、创建泛型-AtomicReference"><a href="#2、创建泛型-AtomicReference" class="headerlink" title="2、创建泛型 AtomicReference"></a>2、创建泛型 AtomicReference</h5><p>你可以使用 Java 泛型来创建一个泛型 AtomicReference。示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AtomicReference&lt;String&gt; atomicStringReference =  </span><br><span class="line">    <span class="keyword">new</span> AtomicReference&lt;String&gt;();</span><br></pre></td></tr></table></figure></p><p>你也可以为泛型 AtomicReference 设置一个初始值。示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String initialReference = <span class="string">"the initially referenced string"</span>;  </span><br><span class="line">AtomicReference&lt;String&gt; atomicStringReference =  </span><br><span class="line">    <span class="keyword">new</span> AtomicReference&lt;String&gt;(initialReference);</span><br></pre></td></tr></table></figure></p><h5 id="3、获取-AtomicReference-引用"><a href="#3、获取-AtomicReference-引用" class="headerlink" title="3、获取 AtomicReference 引用"></a>3、获取 AtomicReference 引用</h5><p>你可以通过 AtomicReference 的 get() 方法来获取保存在 AtomicReference 里的引用。如果你的 AtomicReference 是非泛型的，get() 方法将返回一个 Object 类型的引用。如果是泛型化的，get() 将返回你创建 AtomicReference 时声明的那个类型。先来看一个非泛型的 AtomicReference get() 示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AtomicReference atomicReference = <span class="keyword">new</span> AtomicReference(<span class="string">"first value referenced"</span>);  </span><br><span class="line">String reference = (String) atomicReference.get();</span><br></pre></td></tr></table></figure><p>注意如何对 get() 方法返回的引用强制转换为 String。泛型化的 AtomicReference 示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AtomicReference&lt;String&gt; atomicReference =   </span><br><span class="line">     <span class="keyword">new</span> AtomicReference&lt;String&gt;(<span class="string">"first value referenced"</span>);  </span><br><span class="line">String reference = atomicReference.get();</span><br></pre></td></tr></table></figure></p><p>编译器知道了引用的类型，所以我们无需再对 get() 返回的引用进行强制转换了。</p><h5 id="4、设置-AtomicReference-引用"><a href="#4、设置-AtomicReference-引用" class="headerlink" title="4、设置 AtomicReference 引用"></a>4、设置 AtomicReference 引用</h5><p>你可以使用 get() 方法对 AtomicReference 里边保存的引用进行设置。如果你定义的是一个非泛型 AtomicReference，set() 将会以一个 Object 引用作为参数。如果是泛型化的 AtomicReference，set() 方法将只接受你定义给的类型。AtomicReference set() 示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AtomicReference atomicReference =   </span><br><span class="line">     <span class="keyword">new</span> AtomicReference();  </span><br><span class="line">      </span><br><span class="line">atomicReference.set(<span class="string">"New object referenced"</span>);</span><br></pre></td></tr></table></figure></p><p>这个看起来非泛型和泛型化的没啥区别。真正的区别在于编译器将对你能够设置给一个泛型化的 AtomicReference 参数类型进行限制。</p><h5 id="5、比较并设置-AtomicReference-引用"><a href="#5、比较并设置-AtomicReference-引用" class="headerlink" title="5、比较并设置 AtomicReference 引用"></a>5、比较并设置 AtomicReference 引用</h5><p>AtomicReference 类具备了一个很有用的方法：compareAndSet()。compareAndSet() 可以将保存在 AtomicReference 里的引用于一个期望引用进行比较，如果两个引用是一样的(并非 equals() 的相等，而是 == 的一样)，将会给 AtomicReference 实例设置一个新的引用。</p><p>如果 compareAndSet() 为 AtomicReference 设置了一个新的引用，compareAndSet() 将返回 true。否则 compareAndSet() 返回 false。AtomicReference compareAndSet() 示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String initialReference = <span class="string">"initial value referenced"</span>;  </span><br><span class="line">  </span><br><span class="line">AtomicReference&lt;String&gt; atomicStringReference =  </span><br><span class="line">    <span class="keyword">new</span> AtomicReference&lt;String&gt;(initialReference);  </span><br><span class="line">  </span><br><span class="line">String newReference = <span class="string">"new value referenced"</span>;  </span><br><span class="line"><span class="keyword">boolean</span> exchanged = atomicStringReference.compareAndSet(initialReference, newReference);  </span><br><span class="line">System.out.println(<span class="string">"exchanged: "</span> + exchanged);  </span><br><span class="line">  </span><br><span class="line">exchanged = atomicStringReference.compareAndSet(initialReference, newReference);  </span><br><span class="line">System.out.println(<span class="string">"exchanged: "</span> + exchanged);</span><br></pre></td></tr></table></figure><p>本示例创建了一个带有一个初始引用的泛型化的 AtomicReference。之后两次调用 comparesAndSet()来对存储值和期望值进行对比，如果二者一致，为 AtomicReference 设置一个新的引用。第一次比较，存储的引用(initialReference)和期望的引用(initialReference)一致，所以一个新的引用(newReference)被设置给 AtomicReference，compareAndSet() 方法返回 true。第二次比较时，存储的引用(newReference)和期望的引用(initialReference)不一致，因此新的引用没有被设置给 AtomicReference，compareAndSet() 方法返回 false。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原子性布尔-AtomicBoolean&quot;&gt;&lt;a href=&quot;#原子性布尔-AtomicBoolean&quot; class=&quot;headerlink&quot; title=&quot;原子性布尔 AtomicBoolean&quot;&gt;&lt;/a&gt;原子性布尔 AtomicBoolean&lt;/h1&gt;&lt;p&gt;At
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>不使用synchronized和lock，如何实现一个线程安全的单例？</title>
    <link href="https://ruanyandong.github.io/2020/03/01/%E4%B8%8D%E4%BD%BF%E7%94%A8synchronized%E5%92%8Clock%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E4%BE%8B%EF%BC%9F/"/>
    <id>https://ruanyandong.github.io/2020/03/01/不使用synchronized和lock，如何实现一个线程安全的单例？/</id>
    <published>2020-03-01T14:19:25.000Z</published>
    <updated>2020-03-01T14:44:41.645Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>单例，大家肯定都不陌生，这是Java中很重要的一个设计模式。稍微了解一点单例的朋友也都知道实现单例是要考虑并发问题的，一般情况下，我们都会使用synchronized来保证线程安全。</p><p>那么，如果有这样一道面试题：不使用synchronized和lock，如何实现一个线程安全的单例？你该如何回答？</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h4 id="C类应聘者：可以使用饿汉模式实现单例"><a href="#C类应聘者：可以使用饿汉模式实现单例" class="headerlink" title="C类应聘者：可以使用饿汉模式实现单例"></a>C类应聘者：可以使用饿汉模式实现单例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="还有部分程序员可以想到饿汉的变种"><a href="#还有部分程序员可以想到饿汉的变种" class="headerlink" title="还有部分程序员可以想到饿汉的变种"></a>还有部分程序员可以想到饿汉的变种</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用static来定义静态成员变量或静态代码，借助Class的类加载机制实现线程安全单例。</p><h4 id="B类应聘者：除了以上两种方式，还有一种办法，就是通过静态内部类来实现，代码如下："><a href="#B类应聘者：除了以上两种方式，还有一种办法，就是通过静态内部类来实现，代码如下：" class="headerlink" title="B类应聘者：除了以上两种方式，还有一种办法，就是通过静态内部类来实现，代码如下："></a>B类应聘者：除了以上两种方式，还有一种办法，就是通过静态内部类来实现，代码如下：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式相比前面两种有所优化，就是使用了lazy-loading。Singleton类被装载了，但是instance并没有立即初始化。因为SingletonHolder类没有被主动使用，只有显示通过调用getInstance方法时，才会显示装载SingletonHolder类，从而实例化instance。</p><h4 id="A类应聘者：除了以上方式，还可以使用枚举的方式"><a href="#A类应聘者：除了以上方式，还可以使用枚举的方式" class="headerlink" title="A类应聘者：除了以上方式，还可以使用枚举的方式"></a>A类应聘者：除了以上方式，还可以使用枚举的方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whateverMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式是Effective Java作者Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象，可谓是很坚强的壁垒。</p><ul><li>以上几种答案，其实现原理都是利用借助了类加载的时候初始化单例。即借助了ClassLoader的线程安全机制。</li><li>所谓ClassLoader的线程安全机制，就是ClassLoader的loadClass方法在加载类的时候使用了synchronized关键字。也正是因为这样， 除非被重写，这个方法默认在整个装载过程中都是同步的，也就是保证了线程安全。</li><li>所以，以上各种方法，虽然并没有显示的使用synchronized，但是还是其底层实现原理还是用到了synchronized。</li></ul><h4 id="A类应聘者：还可以使用Java并发包中的Lock实现"><a href="#A类应聘者：还可以使用Java并发包中的Lock实现" class="headerlink" title="A类应聘者：还可以使用Java并发包中的Lock实现"></a>A类应聘者：还可以使用Java并发包中的Lock实现</h4><p>面试官：本质上还是在使用锁，不使用锁的话，有办法实现线程安全的单例吗？</p><h4 id="A-类面试者：有的，那就是使用CAS。"><a href="#A-类面试者：有的，那就是使用CAS。" class="headerlink" title="A+类面试者：有的，那就是使用CAS。"></a>A+类面试者：有的，那就是使用CAS。</h4><p>CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。实现单例的方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicReference&lt;Singleton&gt; INSTANCE = <span class="keyword">new</span> AtomicReference&lt;Singleton&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Singleton singleton = INSTANCE.get();</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != singleton) &#123;</span><br><span class="line">                <span class="keyword">return</span> singleton;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">            <span class="keyword">if</span> (INSTANCE.compareAndSet(<span class="keyword">null</span>, singleton)) &#123;</span><br><span class="line">                <span class="keyword">return</span> singleton;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>面试官：这种方式实现的单例有啥优缺点吗？</p><p>A++类面试者：</p><ul><li>用CAS的好处在于不需要使用传统的锁机制来保证线程安全,CAS是一种基于忙等待的算法,依赖底层硬件的实现,相对于锁它没有线程切换和阻塞的额外消耗,可以支持较大的并行度。</li><li>CAS的一个重要缺点在于如果忙等待一直执行不成功(一直在死循环中),会对CPU造成较大的执行开销。</li><li>另外，如果N个线程同时执行到singleton = new Singleton();的时候，会有大量对象创建，很可能导致内存溢出。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;单例，大家肯定都不陌生，这是Java中很重要的一个设计模式。稍微了解一点单例的朋友也都知道实现单例是要考虑并发问题的，一般情况下，我们都会使
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>生产者与消费者问题</title>
    <link href="https://ruanyandong.github.io/2020/02/27/%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98/"/>
    <id>https://ruanyandong.github.io/2020/02/27/生产者与消费者问题/</id>
    <published>2020-02-27T15:04:49.000Z</published>
    <updated>2020-02-27T15:18:12.352Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><h5 id="线程模型中的经典问题"><a href="#线程模型中的经典问题" class="headerlink" title="线程模型中的经典问题"></a>线程模型中的经典问题</h5><p>生产者和消费者分别为两个线程（或进程），共享一个固定大小的缓冲区（存储空间），生产者往存储空间中添加产品，消费者从存储空间中取走产品，当存储空间为空时，消费者阻塞，当存储空间满时，生产者阻塞。<br><img src="https://img-blog.csdnimg.cn/20200227150132625.png" alt="在这里插入图片描述"></p><h5 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h5><ul><li>制造数据并且在缓冲区未满时写入，否则等待；</li><li>在缓冲区为空的情况下写入数据并唤醒消费者读取数据；<h5 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h5></li><li>在缓冲区不为空时读出数据，否则等待；</li><li>在缓冲区满的情况下消费数据并唤醒生产者写入数据。</li></ul><h5 id="问题关键"><a href="#问题关键" class="headerlink" title="问题关键"></a>问题关键</h5><ul><li><p>对缓冲区进行互斥处理，缓冲区为临界区，防止竞争；</p></li><li><p>正确实现生产者和消费者的同步关系，防止出现死锁。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="wait-和notify-方法的实现"><a href="#wait-和notify-方法的实现" class="headerlink" title="wait()和notify()方法的实现"></a>wait()和notify()方法的实现</h2><p>缓冲区满和为空时都调用wait()方法等待，当生产者生产了一个产品或者消费者消费了一个产品之后会唤醒所有线程。</p><h5 id="关于wait-和notify"><a href="#关于wait-和notify" class="headerlink" title="关于wait()和notify()"></a>关于wait()和notify()</h5></li><li><p>wait(): 调用任何对象的wait()方法会让当前线程进入等待状态，会把当前的锁释放，然后让出CPU，直到另一个线程调用同一个对象的notify()或notifyAll()方法。</p></li><li><p>notify(): 唤醒因调用这个对象wait()方法而阻塞的线程，然后继续往下执行，直到执行完退出对象锁锁住的区域（synchronized修饰的代码块）后再释放锁。</p></li><li><p>wait()/notify()直接隶属于Object 类，所有对象都拥有这一对方法。</p></li><li><p>这一对方法却必须在 synchronized方法或块中调用，只有在synchronized 方法或块中当前线程才占有锁，才有锁可以释放。调用这一对方法的对象上的锁必须为当前线程所拥有，这样才有锁可以释放。因此，这一对方法调用必须放置在这样的 synchronized方法或块中，该方法或块的上锁对象就是调用这一对方法的对象。若不满足这一条件，则程序虽然仍能编译，但在运行时会出现IllegalMonitorStateException异常。</p></li><li><p>调用 notify() 方法导致解除阻塞的线程是从因调用该对象的 wait() 方法而阻塞的线程中随机选取的，我们无法预料哪一个线程将会被选择，所以编程时要特别小心，避免因这种不确定性而产生问题</p></li><li><p>除了 notify()，还有一个方法 notifyAll() 也可起到类似作用，唯一的区别在于，调用 notifyAll() 方法将把因调用该对象的 wait() 方法而阻塞的所有线程一次性全部解除阻塞。当然，只有获得锁的那一个线程才能进入可执行状态。</p></li><li><p>wait()和notify()必须成对存在。</p><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录产品的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 限定产品的总数量为10</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FULL = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 锁对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK = <span class="string">"LOCK"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProducerConsumer producerConsumer = <span class="keyword">new</span> ProducerConsumer();</span><br><span class="line">        <span class="comment">// 线程池执行</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">8</span>);</span><br><span class="line">        service.execute(producerConsumer.new Producer());</span><br><span class="line">        service.execute(producerConsumer.new Consumer());</span><br><span class="line">        service.execute(producerConsumer.new Producer());</span><br><span class="line">        service.execute(producerConsumer.new Consumer());</span><br><span class="line">        service.execute(producerConsumer.new Producer());</span><br><span class="line">        service.execute(producerConsumer.new Consumer());</span><br><span class="line">        service.execute(producerConsumer.new Producer());</span><br><span class="line">        service.execute(producerConsumer.new Consumer());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (count == FULL) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            LOCK.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    count++;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"生产者生产，目前总共有"</span> + count);</span><br><span class="line">                    LOCK.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            LOCK.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    count--;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"消费者消费，目前总共有"</span> + count);</span><br><span class="line">                    LOCK.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">8</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">7</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">6</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>生产者生产，目前总共有<span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span>消费者消费，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">7</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>生产者生产，目前总共有<span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>生产者生产，目前总共有<span class="number">3</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">8</span>消费者消费，目前总共有<span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">6</span>消费者消费，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">6</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">7</span>生产者生产，目前总共有<span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">8</span>消费者消费，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">7</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">8</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">6</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span>生产者生产，目前总共有<span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">8</span>消费者消费，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>生产者生产，目前总共有<span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">6</span>消费者消费，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">7</span>生产者生产，目前总共有<span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span>消费者消费，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">7</span>生产者生产，目前总共有<span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>生产者生产，目前总共有<span class="number">3</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">6</span>消费者消费，目前总共有<span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">8</span>消费者消费，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>生产者生产，目前总共有<span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span>消费者消费，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">8</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">7</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span>生产者生产，目前总共有<span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">6</span>消费者消费，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>生产者生产，目前总共有<span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>消费者消费，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">7</span>生产者生产，目前总共有<span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">6</span>消费者消费，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span>生产者生产，目前总共有<span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">8</span>消费者消费，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span>生产者生产，目前总共有<span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">6</span>消费者消费，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">7</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">8</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">7</span>生产者生产，目前总共有<span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span>生产者生产，目前总共有<span class="number">3</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">6</span>消费者消费，目前总共有<span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>消费者消费，目前总共有<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">8</span>消费者消费，目前总共有<span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="阻塞队列BlockingQueue的实现"><a href="#阻塞队列BlockingQueue的实现" class="headerlink" title="阻塞队列BlockingQueue的实现"></a>阻塞队列BlockingQueue的实现</h2><p>BlockingQueue即阻塞队列，在某些情况下对阻塞队列的访问可能会造成阻塞。</p><h5 id="被阻塞的情况主要有如下两种"><a href="#被阻塞的情况主要有如下两种" class="headerlink" title="被阻塞的情况主要有如下两种:"></a>被阻塞的情况主要有如下两种:</h5><ul><li>当队列满了的时候进行入队列操作</li><li>当队列空了的时候进行出队列操作</li><li>当一个线程对已经满了的阻塞队列进行入队操作时会阻塞，除非有另外一个线程进行了出队操作，当一个线程对一个空的阻塞队列进行出队操作时也会阻塞，除非有另外一个线程进行了入队操作。</li><li>阻塞队列是线程安全的。</li></ul><h5 id="BlockingQueue接口的一些方法"><a href="#BlockingQueue接口的一些方法" class="headerlink" title="BlockingQueue接口的一些方法:"></a>BlockingQueue接口的一些方法:</h5><table><thead><tr><th>操作</th><th>抛异常</th><th>特定值</th><th>阻塞</th><th>超时</th></tr></thead><tbody><tr><td>插入</td><td>add(o)</td><td>offer(o)</td><td>put(o)</td><td>offer(o, timeout, timeunit)</td></tr><tr><td>移除</td><td>remove(o)</td><td>poll(o)</td><td>take(o)</td><td>poll(timeout, timeunit)</td></tr><tr><td>检查</td><td>element(o)</td><td>peek(o)</td><td></td></tr></tbody></table><p>这四类方法分别对应的是：</p><ul><li>ThrowsException：如果操作不能马上进行，则抛出异常</li><li>SpecialValue：如果操作不能马上进行，将会返回一个特殊的值，一般是true或者false</li><li>Blocks:如果操作不能马上进行，操作会被阻塞</li><li>TimesOut:如果操作不能马上进行，操作会被阻塞指定的时间，如果指定时间没执行，则返回一个特殊值，一般是true或者false<h5 id="BlockingQueue方法对比"><a href="#BlockingQueue方法对比" class="headerlink" title="BlockingQueue方法对比"></a>BlockingQueue方法对比</h5>|方法|描述|<br>|–|–|<br>|boolean add(E e)|    如果可能，向队列中添加一个元素。否则，它抛出异常。|<br>|boolean offer(E e)|    如果能添加元素，则将元素添加到队列中，而不抛出异常。 它在失败时返回false，在成功时返回true。|<br>|E remove()|    删除队列的头。如果队列为空，它会抛出异常。此方法返回已移除的项目。|<br>|E poll()|    从队列中删除元素。如果队列为空而不是抛出异常，则返回null。|<br>|Eelement()|    查看队列的头，而不从队列中删除它。 如果队列为空，它会抛出异常。|<br>|E peek()|    查看队列，如果队列为空而不是抛出异常，则返回null。|<br>|void put(E e)|put方法只存在于<strong><strong>BlockingQueue类型的阻塞队列中，使用put方法向已满的队列添加新元素时，代码会阻塞在put处|<br>|E take()|take方法只存在于</strong></strong>BlockingQueue类型的阻塞队列中，获得空队列的头部元素时，会阻塞在获取的位置|</li></ul><p>下面看由阻塞队列实现的生产者消费者模型,这里使用take()和put()方法，消费者和消费者之间不存在同步，所以会出现连续生成和连续消费的现象。</p><h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录产品的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 创建阻塞队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProducerConsumer producerConsumer = <span class="keyword">new</span> ProducerConsumer();</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">8</span>);</span><br><span class="line">        service.execute(producerConsumer.new Producer());</span><br><span class="line">        service.execute(producerConsumer.new Consumer());</span><br><span class="line">        service.execute(producerConsumer.new Producer());</span><br><span class="line">        service.execute(producerConsumer.new Consumer());</span><br><span class="line">        service.execute(producerConsumer.new Producer());</span><br><span class="line">        service.execute(producerConsumer.new Consumer());</span><br><span class="line">        service.execute(producerConsumer.new Producer());</span><br><span class="line">        service.execute(producerConsumer.new Consumer());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    blockingQueue.put(<span class="number">1</span>);</span><br><span class="line">                    count++;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()</span><br><span class="line">                            + <span class="string">"生产者生产，目前总共有"</span> + count);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    blockingQueue.take();</span><br><span class="line">                    count--;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()</span><br><span class="line">                            + <span class="string">"消费者消费，目前总共有"</span> + count);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可重入锁ReentrantLock的实现"><a href="#可重入锁ReentrantLock的实现" class="headerlink" title="可重入锁ReentrantLock的实现"></a>可重入锁ReentrantLock的实现</h2><h5 id="ReentrantLock简介"><a href="#ReentrantLock简介" class="headerlink" title="ReentrantLock简介"></a>ReentrantLock简介</h5><ul><li>通过ReentrantLock对象的lock()方法和unlock()方法实现了对锁的显示控制，而synchronize()则是对锁的隐性控制。</li><li>可重入锁，也叫做递归锁，简单来说，该锁维护这一个与获取锁相关的计数器，如果拥有锁的某个线程再次得到锁，那么获取计数器就加1，函数调用结束计数器就减1，然后锁需要被释放两次才能获得真正释放。已经获取锁的线程进入其他需要相同锁的同步代码块不会被阻塞。</li><li>从Java 5开始，引入了一个高级的处理并发的java.util.concurrent包，它提供了大量更高级的并发功能，能大大简化多线程程序的编写。</li><li>Java语言直接提供了synchronized关键字用于加锁，但这种锁一是很重，二是获取时必须一直等待，没有额外的尝试机制。</li></ul><p>java.util.concurrent.locks包提供的ReentrantLock用于替代synchronized加锁，我们来看一下传统的synchronized代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用ReentrantLock替代，可以把代码改造为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>因为synchronized是Java语言层面提供的语法，所以我们不需要考虑异常，而ReentrantLock是Java代码实现的锁，我们就必须先获取锁，然后在finally中正确释放锁。</li><li>顾名思义，ReentrantLock是可重入锁，它和synchronized一样，一个线程可以多次获取同一个锁。</li><li>和synchronized不同的是，ReentrantLock可以尝试获取锁：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (lock.tryLock(<span class="number">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上述代码在尝试获取锁的时候，最多等待1秒。如果1秒后仍未获取到锁，tryLock()返回false，程序就可以做一些额外处理，而不是无限等待下去。</li><li>所以，使用ReentrantLock比直接使用synchronized更安全，线程在tryLock()失败的时候不会导致死锁。</li><li>ReentrantLock可以替代synchronized进行同步；</li><li>ReentrantLock获取锁更安全；</li><li>必须先获取到锁，再进入try {…}代码块，最后使用finally保证释放锁；</li><li>可以使用tryLock()尝试获取锁。<h5 id="Condition简介"><a href="#Condition简介" class="headerlink" title="Condition简介"></a>Condition简介</h5>synchronized可以配合wait和notify实现线程在条件不满足时等待，条件满足时唤醒，用ReentrantLock我们怎么编写wait和notify的功能呢？</li></ul><p>答案是使用Condition对象来实现wait和notify的功能。</p><p>我们仍然以TaskQueue为例，把前面用synchronized实现的功能通过ReentrantLock和Condition来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition condition = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTask</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            queue.add(s);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> queue.remove();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，使用Condition时，引用的Condition对象必须从Lock实例的newCondition()返回，这样才能获得一个绑定了Lock实例的Condition实例。</p><p>Condition提供的await()、signal()、signalAll()原理和synchronized锁对象的wait()、notify()、notifyAll()是一致的，并且其行为也是一样的：</p><ul><li><p>await()会释放当前锁，进入等待状态；</p></li><li><p>signal()会唤醒某个等待线程；</p></li><li><p>signalAll()会唤醒所有等待线程；</p></li></ul><p>唤醒线程从await()返回后需要重新获得锁。</p><p>此外，和tryLock()类似，await()可以在等待指定时间后，如果还没有被其他线程通过signal()或signalAll()唤醒，可以自己醒来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition.await(<span class="number">1</span>, TimeUnit.SECOND)) &#123;</span><br><span class="line">    <span class="comment">// 被其他线程唤醒</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 指定时间内没有被其他线程唤醒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，使用Condition配合Lock，我们可以实现更灵活的线程同步。</p><h5 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录产品的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer FULL = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//创建一个锁对象</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">//创建两个条件变量，一个为缓冲区已满，一个为缓冲区非空</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition alreadyFull = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProducerConsumer producerConsumer = <span class="keyword">new</span> ProducerConsumer();</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">8</span>);</span><br><span class="line">        service.execute(producerConsumer.new Producer());</span><br><span class="line">        service.execute(producerConsumer.new Consumer());</span><br><span class="line">        service.execute(producerConsumer.new Producer());</span><br><span class="line">        service.execute(producerConsumer.new Consumer());</span><br><span class="line">        service.execute(producerConsumer.new Producer());</span><br><span class="line">        service.execute(producerConsumer.new Consumer());</span><br><span class="line">        service.execute(producerConsumer.new Producer());</span><br><span class="line">        service.execute(producerConsumer.new Consumer());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//获取锁</span></span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (count == FULL) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            alreadyFull.await();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    count++;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()</span><br><span class="line">                            + <span class="string">"生产者生产，目前总共有"</span> + count);</span><br><span class="line">                    <span class="comment">//唤醒消费者</span></span><br><span class="line">                    notEmpty.signal();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//释放锁</span></span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            notEmpty.await();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    count--;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()</span><br><span class="line">                            + <span class="string">"消费者消费，目前总共有"</span> + count);</span><br><span class="line">                    alreadyFull.signal();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="信号量Semaphore的实现"><a href="#信号量Semaphore的实现" class="headerlink" title="信号量Semaphore的实现"></a>信号量Semaphore的实现</h2><ul><li>Semaphore(信号量)是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源，在操作系统中是一个非常重要的问题，可以用来解决哲学家就餐问题。</li><li>Java中的Semaphore维护了一个许可集，一开始先设定这个许可集的数量，可以使用acquire()方法获得一个许可，当许可不足时会被阻塞，release()添加一个许可。在下列代码中，还加入了另外一个mutex信号量，维护生产者消费者之间的同步关系，保证生产者和消费者之间的交替进行<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录产品的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//创建三个信号量</span></span><br><span class="line">    <span class="keyword">final</span> Semaphore producer = <span class="keyword">new</span> Semaphore(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">final</span> Semaphore consumer = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">final</span> Semaphore mutex = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProducerConsumer producerConsumer = <span class="keyword">new</span> ProducerConsumer();</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">8</span>);</span><br><span class="line">        service.execute(producerConsumer.new Producer());</span><br><span class="line">        service.execute(producerConsumer.new Consumer());</span><br><span class="line">        service.execute(producerConsumer.new Producer());</span><br><span class="line">        service.execute(producerConsumer.new Consumer());</span><br><span class="line">        service.execute(producerConsumer.new Producer());</span><br><span class="line">        service.execute(producerConsumer.new Consumer());</span><br><span class="line">        service.execute(producerConsumer.new Producer());</span><br><span class="line">        service.execute(producerConsumer.new Consumer());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    producer.acquire();</span><br><span class="line">                    mutex.acquire();</span><br><span class="line">                    count++;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()</span><br><span class="line">                            + <span class="string">"生产者生产，目前总共有"</span> + count);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    mutex.release();</span><br><span class="line">                    consumer.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    consumer.acquire();</span><br><span class="line">                    mutex.acquire();</span><br><span class="line">                    count--;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()</span><br><span class="line">                            + <span class="string">"消费者消费，目前总共有"</span> + count);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    mutex.release();</span><br><span class="line">                    producer.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="管道输入输出流PipedInputStream和PipedOutputStream实现"><a href="#管道输入输出流PipedInputStream和PipedOutputStream实现" class="headerlink" title="管道输入输出流PipedInputStream和PipedOutputStream实现"></a>管道输入输出流PipedInputStream和PipedOutputStream实现</h2><ul><li>在java的io包下，PipedOutputStream和PipedInputStream分别是管道输出流和管道输入流。它们的作用是让多线程可以通过管道进行线程间的通讯。在使用管道通信时，必须将PipedOutputStream和PipedInputStream配套使用。</li><li>使用方法：先创建一个管道输入流和管道输出流，然后将输入流和输出流进行连接，用生产者线程往管道输出流中写入数据，消费者在管道输入流中读取数据，这样就可以实现了不同线程间的相互通讯，但是这种方式在生产者和生产者、消费者和消费者之间不能保证同步，也就是说在一个生产者和一个消费者的情况下是可以生产者和消费者之间交替运行的，多个生成者和多个消费者者之间则不行<h5 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h5></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> PipedInputStream pis = <span class="keyword">new</span> PipedInputStream();</span><br><span class="line">    <span class="keyword">final</span> PipedOutputStream pos = <span class="keyword">new</span> PipedOutputStream();</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            pis.connect(pos);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProducerConsumer producerConsumer = <span class="keyword">new</span> ProducerConsumer();</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        service.execute(producerConsumer.new Producer());</span><br><span class="line">        service.execute(producerConsumer.new Consumer());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    <span class="keyword">int</span> num = (<span class="keyword">int</span>) (Math.random() * <span class="number">255</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"生产者生产了一个数字，该数字为： "</span> + num);</span><br><span class="line">                    pos.write(num);</span><br><span class="line">                    pos.flush();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    pos.close();</span><br><span class="line">                    pis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    <span class="keyword">int</span> num = pis.read();</span><br><span class="line">                    System.out.println(<span class="string">"消费者消费了一个数字，该数字为："</span> + num);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    pos.close();</span><br><span class="line">                    pis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;h5 id=&quot;线程模型中的经典问题&quot;&gt;&lt;a href=&quot;#线程模型中的经典问题&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>git reset 和 revert</title>
    <link href="https://ruanyandong.github.io/2020/02/17/git-reset-%E5%92%8C-revert/"/>
    <id>https://ruanyandong.github.io/2020/02/17/git-reset-和-revert/</id>
    <published>2020-02-17T13:30:15.000Z</published>
    <updated>2020-02-17T13:33:16.636Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在利用git实现多人合作开发程序的过程中，有时会出现错误提交的情况，此时希望能撤销提交操作，让程序回到提交前的样子，本文总结了两种方法：reset（重置）、revert（恢复）。</p><p>先简单说一下，在提交到远程库之前我们使用<strong>git reset</strong> 命令完全可以满足我们 撤销操作的需求，如果操作已经提交到远程库，那只好使用 <strong>git revert</strong> 来提交一个新的撤销操作 撤销 需要撤销的那次commit。</p><h1 id="git的工作流"><a href="#git的工作流" class="headerlink" title="git的工作流"></a>git的工作流</h1><ul><li><p><strong>工作区</strong>：即自己当前分支所修改的代码，git add xx 之前的！不包括 git add xx 和 git commit xxx 之后的。</p></li><li><p><strong>暂存区</strong>：已经 git add xxx 进去，且未 git commit xxx 的。</p></li><li><p><strong>本地分支</strong>：已经git commit -m xxx 提交到本地分支的。</p></li></ul><p>在将文件提交至远程端时，文件的提交需要经过<strong>git add</strong>、<strong>git commit</strong>及<strong>git push</strong>三个过程才能提交至git远程仓库。我们平时修改文件在<strong>工作目录</strong>中，提交时先使用git add提交至<strong>暂存区</strong>，再通过git commit提交至<strong>本地仓库</strong>，最后才能使用git push提交至远程仓库。</p><ul><li><strong>在工作区的代码</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- a.txt   <span class="comment"># 丢弃某个文件，或者</span></span><br><span class="line">git checkout -- .       <span class="comment"># 丢弃全部</span></span><br></pre></td></tr></table></figure><p>注意：git checkout – . 丢弃全部，也包括：新增的文件会被删除、删除的文件会恢复回来、修改的文件会回去。这几个前提都说的是，回到暂存区之前的样子。对之前保存在暂存区里的代码不会有任何影响。对commit提交到本地分支的代码就更没影响了。当然，如果你之前压根都没有暂存或commit，那就是回到你上次pull下来的样子了。</p><ul><li><strong>代码git add到缓存区，并未commit提交</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD .  或者</span><br><span class="line">git reset HEAD a.txt</span><br></pre></td></tr></table></figure><p>这个命令仅改变暂存区，并不改变工作区，这意味着在无任何其他操作的情况下，工作区中的实际文件同该命令运行之前无任何变化</p><ul><li><strong>git commit到本地分支、但没有git push到远程</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> <span class="comment"># 得到你需要回退一次提交的commit id</span></span><br><span class="line">git reset --hard &lt;commit_id&gt;  <span class="comment"># 回到其中你想要的某个版</span></span><br><span class="line">或者</span><br><span class="line">git reset --hard HEAD^  <span class="comment"># 回到最新的一次提交</span></span><br><span class="line">或者</span><br><span class="line">git reset HEAD^  <span class="comment"># 此时代码保留，回到 git add 之前</span></span><br></pre></td></tr></table></figure><ul><li><strong>git push把修改提交到远程仓库</strong><br>1）通过git reset是直接删除指定的commit</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> <span class="comment"># 得到你需要回退一次提交的commit id</span></span><br><span class="line">git reset --hard &lt;commit_id&gt;</span><br><span class="line">git push origin HEAD --force <span class="comment"># 强制提交一次，之前错误的提交就从远程仓库删除</span></span><br></pre></td></tr></table></figure><p>2）通过git revert是用一次新的commit来回滚之前的commit</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> <span class="comment"># 得到你需要回退一次提交的commit id</span></span><br><span class="line">git revert &lt;commit_id&gt;  <span class="comment"># 撤销指定的版本，撤销也会作为一次提交进行保存</span></span><br><span class="line">git commit -m <span class="string">"......."</span> </span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>开发过程中，你肯定会遇到这样的场景：</p><p>场景一：</p><pre><code>糟了，我刚把不想要的代码，commit到本地仓库中了，但是还没有做push操作！</code></pre><p>场景二：</p><pre><code>彻底完了，刚线上更新的代码出现问题了，需要还原这次提交的代码！</code></pre><p>场景三：</p><pre><code>刚才我发现之前的某次提交太愚蠢了，现在想要干掉它！</code></pre><p>撤销</p><p>上述场景一，在未进行git push前的所有操作，都是在“本地仓库”中执行的。我们暂且将“本地仓库”的代码还原操作叫做“撤销”！</p><p>情况一：文件被修改了，但未执行git add操作(working tree内撤销)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout fileName</span><br><span class="line">git checkout .</span><br></pre></td></tr></table></figure><p>情况二：同时对多个文件执行了git add操作，但本次只想提交其中一部分文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add *</span><br><span class="line">$ git status</span><br><span class="line"><span class="comment"># 取消暂存</span></span><br><span class="line">$ git reset HEAD &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>情况三：文件执行了git add操作，但想撤销对其的修改（index内回滚）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 取消暂存</span></span><br><span class="line"> git reset HEAD fileName</span><br><span class="line"> <span class="comment"># 撤销修改</span></span><br><span class="line"> git checkout fileName</span><br></pre></td></tr></table></figure><p>情况四：修改的文件已被git commit，但想再次修改不再产生新的Commit</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改最后一次提交 </span></span><br><span class="line">  $ git add sample.txt</span><br><span class="line">  $ git commit --amend -m<span class="string">"说明"</span></span><br></pre></td></tr></table></figure><h1 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h1><p>git reset中有三个命令（–hard、–soft与–mixed）；主要用于工作区、暂存区、本地仓库三个区域的文件提交撤回</p><ul><li>git reset –hard xxx</li></ul><p>hard （修改版本库，修改暂存区，修改工作区）</p><p>–hard HEAD～1 (或是版本号)意为将版本库回退1个版本，但是不仅仅是将本地版本库的头指针全部重置到指定版本，也会重置暂存区，并且会将工作区代码也回退到这个版本</p><ul><li><p>git reset –soft xxx</p><p>soft （修改版本库，保留暂存区，保留工作区）</p></li></ul><p>–soft HEAD～1 意为将版本库软回退1个版本，所谓软回退表示将本地版本库的头指针全部重置到指定版本，且将这次提交之后的所有变更都移动到暂存区。</p><h1 id="revert"><a href="#revert" class="headerlink" title="revert"></a>revert</h1><ul><li>git revert xxx</li></ul><p>– git revert 也是撤销命令，区别在于reset是指向原地或者向前移动指针，git revert是创建一个commit来覆盖当前的commit，指针向后移动。</p><h1 id="git-revert-和-git-reset的区别"><a href="#git-revert-和-git-reset的区别" class="headerlink" title="git revert 和 git reset的区别"></a>git revert 和 git reset的区别</h1><ul><li>git revert是用一次新的commit来回滚之前的commit，此次提交之前的commit都会被保留；</li><li>git reset是回到某次提交，提交及之前的commit都会被保留，但是此commit id之后的修改都会被删除</li><li>git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit。</li></ul><ul><li>在回滚这一操作上看，效果差不多。但是在日后继续merge以前的老版本时有区别。因为git revert是用一次逆向的commit“中和”之前的提交，因此日后合并老的branch时，导致这部分改变不会再次出现，但是git reset是之间把某些commit在某个branch上删除，因而和老的branch再次merge时，这些被回滚的commit应该还会被引入。</li><li>git reset 是把HEAD向后移动了一下，而git revert是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;在利用git实现多人合作开发程序的过程中，有时会出现错误提交的情况，此时希望能撤销提交操作，让程序回到提交前的样子，本文总结了两种方法：re
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>git merge 和 rebase</title>
    <link href="https://ruanyandong.github.io/2020/02/17/git-merge-%E5%92%8C-rebase/"/>
    <id>https://ruanyandong.github.io/2020/02/17/git-merge-和-rebase/</id>
    <published>2020-02-17T13:19:20.000Z</published>
    <updated>2020-02-17T13:21:45.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h1><p>假设你现在基于远程分支”origin”，创建一个叫”mywork”的分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b mywork origin</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200217185852996.png" alt="在这里插入图片描述"><br>现在我们在这个分支做一些修改，然后生成两个提交(commit).</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ vi file.txt</span><br><span class="line">$ git commit</span><br><span class="line">$ vi otherfile.txt</span><br><span class="line">$ git commit</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>但是与此同时，有些人也在”origin”分支上做了一些修改并且做了提交了. 这就意味着”origin”和”mywork”这两个分支各自”前进”了，它们之间”分叉”了。<br><img src="https://img-blog.csdnimg.cn/20200217190033870.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0NjgxNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>在这里，你可以用”pull”命令把”origin”分支上的修改拉下来并且和你的修改合并； 结果看起来就像一个新的”合并的提交”(merge commit):<br><img src="https://img-blog.csdnimg.cn/20200217190249605.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0NjgxNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>但是，如果你想让”mywork”分支历史看起来像没有经过任何合并一样，你也许可以用 git rebase:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout mywork</span><br><span class="line">$ git rebase origin</span><br></pre></td></tr></table></figure><p>这些命令会把你的”mywork”分支里的每个提交(commit)取消掉，并且把它们临时 保存为补丁(patch)(这些补丁放到”.git/rebase”目录中),然后把”mywork”分支更新 到最新的”origin”分支，最后把保存的这些补丁应用到”mywork”分支上。<br><img src="https://img-blog.csdnimg.cn/20200217190341269.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0NjgxNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>当’mywork’分支更新之后，它会指向这些新创建的提交(commit),而那些老的提交会被丢弃。 如果运行垃圾收集命令(pruning garbage collection), 这些被丢弃的提交就会删除. （请查看 git gc)<br><img src="https://img-blog.csdnimg.cn/20200217190435390.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0NjgxNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>现在我们可以看一下用合并(merge)和用rebase所产生的历史的区别：<br><img src="https://img-blog.csdnimg.cn/20200217190631810.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0NjgxNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> </p><ul><li>1-2-3 是现在的分支状态</li><li>这个时候从原来的master ,checkout出来一个prod分支</li><li>然后master提交了4.5，prod提交了6.7</li><li>这个时候master分支状态就是1-2-3-4-5，prod状态变成1-2-3-6-7</li><li>如果在prod上用rebase master ,prod分支状态就成了1-2-3-4-5-6-7</li><li>如果是merge 1-2-3-6-7-8  …….. |4-5|</li><li>会出来一个8，这个8的提交就是把4-5合进来的提交</li></ul><p>在rebase的过程中，也许会出现冲突(conflict). 在这种情况，Git会停止rebase并会让你去解决 冲突；在解决完冲突后，用”git-add”命令去更新这些内容的索引(index), 然后，你无需执行 git-commit,只要执行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure><p>这样git会继续应用(apply)余下的补丁。</p><p>在任何时候，你可以用–abort参数来终止rebase的行动，并且”mywork” 分支会回到rebase开始前的状态。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase --abort</span><br></pre></td></tr></table></figure><h2 id="git-pull和git-pull-–rebase区别"><a href="#git-pull和git-pull-–rebase区别" class="headerlink" title="git pull和git pull –rebase区别"></a><strong>git pull</strong>和<strong>git pull –rebase</strong>区别</h2><p><strong>git pul</strong>l做了两个操作分别是‘获取’和合并。所以加了rebase就是以rebase的方式进行合并分支，默认为merge。</p><h2 id="git-merge-和-git-merge-–no-ff的区别"><a href="#git-merge-和-git-merge-–no-ff的区别" class="headerlink" title="git merge 和 git merge –no-ff的区别"></a>git merge 和 git merge –no-ff的区别</h2><p>1、尝试merge命令后，发现：merge时并没有产生一个commit。不是说merge时会产生一个merge commit吗？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意:只有在冲突的时候，解决完冲突才会自动产生一个commit。</span><br></pre></td></tr></table></figure><p>如果想在没有冲突的情况下也自动生成一个commit，记录此次合并就可以用：<strong>git merge –no-ff</strong>命令，下面用一张图来表示两者的区别：<br><img src="https://img-blog.csdnimg.cn/20200217192653541.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0NjgxNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">2、如果不加 –no-ff 则被合并的分支之前的commit都会被抹去，只会保留一个解决冲突后的 merge commit。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://gitbook.liuhui998.com/4_2.html" target="_blank" rel="noopener">merge和rebase</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;rebase&quot;&gt;&lt;a href=&quot;#rebase&quot; class=&quot;headerlink&quot; title=&quot;rebase&quot;&gt;&lt;/a&gt;rebase&lt;/h1&gt;&lt;p&gt;假设你现在基于远程分支”origin”，创建一个叫”mywork”的分支。&lt;/p&gt;
&lt;figure clas
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>git revert踩坑之路</title>
    <link href="https://ruanyandong.github.io/2020/02/16/git-revert%E8%B8%A9%E5%9D%91%E4%B9%8B%E8%B7%AF/"/>
    <id>https://ruanyandong.github.io/2020/02/16/git-revert踩坑之路/</id>
    <published>2020-02-16T15:26:45.000Z</published>
    <updated>2020-02-16T15:27:59.125Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在实际的开发工作中，使用git总会遇到一堆问题，本文将结合具体例子，讲述在何种条件下会出发<strong>git revert失败</strong>以及<strong>解决的方案和措施</strong>。</p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>首先，创建一个git 仓库（repo），本人是在Mac环境下，Windows下打开git 命令行，但代码是一样的：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir git-revert</span><br><span class="line"><span class="built_in">cd</span> git-revert</span><br><span class="line">git init</span><br></pre></td></tr></table></figure></p><p>首先创建两个 commit 来模拟 master 上现有的 commit 记录：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'file1'</span> &gt; file1 </span><br><span class="line">git add . &amp;&amp; git commit -m <span class="string">'commit 1'</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'file2'</span> &gt; file2</span><br><span class="line">git add . &amp;&amp; git commit -m <span class="string">'commit 2'</span></span><br></pre></td></tr></table></figure></p><p>现在我们需要开发一个新功能，所以需要基于master分支拉了一个新分支dev，我们创建并切换到dev分支：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch dev</span><br><span class="line">git checkout dev </span><br><span class="line"><span class="comment"># 或者使用 git checkout -b dev 合上面两步效果一样</span></span><br></pre></td></tr></table></figure></p><p>接下来我们添加两个commit来完成dev分支：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'file3'</span> &gt; file3</span><br><span class="line">git add . &amp;&amp; git commit -m <span class="string">'dev - commit 1'</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'file4'</span> &gt; file4</span><br><span class="line">git add . &amp;&amp; git commit -m <span class="string">'dev - commit 2'</span></span><br></pre></td></tr></table></figure></p><p>在dev分支开发过程中，master 分支上通常会有其他人新的 commit提交，于是我们回到 master，来模拟一下这些 commit:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'file5'</span> &gt; file5</span><br><span class="line">git add . &amp;&amp; git commit -m <span class="string">'commit 3'</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'file6'</span> &gt; file6</span><br><span class="line">git add . &amp;&amp; git commit -m <span class="string">'commit 4'</span></span><br></pre></td></tr></table></figure></p><p>这个时候，dev分支测试通过了，需要合并到master分支上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge dev</span><br></pre></td></tr></table></figure><p>如图所示：<br><img src="https://img-blog.csdnimg.cn/20200121120329144.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0NjgxNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>后来，master 上又多了一些 commit：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'file7'</span> &gt; file7</span><br><span class="line">git add . &amp;&amp; git commit -m <span class="string">'commit 5'</span></span><br></pre></td></tr></table></figure></p><p>由于dev分支有问题，不想合并master分支，想revert这次merge commit，那就revert吧。<br>首先，先git log看一下：<br><img src="https://img-blog.csdnimg.cn/20200121143718784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0NjgxNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>找到merge的commit id来revert，711b06，<br><img src="https://img-blog.csdnimg.cn/20200121144304989.png" alt="在这里插入图片描述"><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert 711b06</span><br></pre></td></tr></table></figure></p><p>问题出现了，revert失败：<br><img src="https://img-blog.csdnimg.cn/2020012114453925.png" alt="在这里插入图片描述"></p><h1 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h1><p>再次给出错误信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: commit 711b06365ec6ced517bf2597fa1b7562060e1181 is a merge but no -m option was given.</span><br></pre></td></tr></table></figure></p><p>我们来看看 -m 到底指的是什么, 查看官方文档, 可以看到：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-m parent-number</span><br><span class="line">--mainline parent-number</span><br><span class="line">Usually you cannot revert a merge because you <span class="keyword">do</span> not know <span class="built_in">which</span> side of the merge should be considered the mainline. This option specifies the parent number (starting from 1) of the mainline and allows revert to reverse the change relative to the specified parent.</span><br><span class="line"></span><br><span class="line">Reverting a merge commit declares that you will never want the tree changes brought <span class="keyword">in</span> by the merge. As a result, later merges will only bring <span class="keyword">in</span> tree changes introduced by commits that are not ancestors of the previously reverted merge. This may or may not be what you want.</span><br></pre></td></tr></table></figure></p><p>翻译过来就是:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">通常情况下，你无法 revert 一个 merge，因为你不知道 merge 的哪一条线应该被视为主线。这个选项（-m）指定了主线的 parent 的代号（从1开始），并允许以相对于指定的 parent 的进行 revert。</span><br><span class="line"></span><br><span class="line">revert 一个 merge commit 意味着你将完全不想要来自 merge commit 带来的 tree change。 因此，之后的 merge 只会引入那些不是之前被 revert 的那个 merge 的祖先引入的 tree change，这可能是也可能不是你想要的。</span><br></pre></td></tr></table></figure><p>由于 merge commit 是将两条线合并到一条线上，因此，合并时的那个commit，将具有两个祖先。所以 git 不知道 base 是选择哪个 parent 进行 diff，所以你要用 -m 属性显示地告诉 git 用哪一个 parent。<br>那么，如何查看当前的commit有几个祖先呢？<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show 711b06</span><br></pre></td></tr></table></figure></p><p><img src="https://img-blog.csdnimg.cn/20200121145947797.png" alt="在这里插入图片描述"><br>Merge 这个字段便标明了当前的parent，分别是 0ffc72f 和 8f1dbff</p><p><strong>当你在 B 分支上把 A merge 到 B 中，那么 B 就是merge commit 的 parent1，而 A 是 parent2，所以，master分支是parent1，dev分支是parent2。</strong></p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>有了上一节的分析，我们可以很直接地给出以下可用的代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert 711b06 -m 1</span><br></pre></td></tr></table></figure></p><p>输出以下log：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Revert <span class="string">"Merge branch 'dev'"</span></span><br><span class="line">  </span><br><span class="line">This reverts commit 711b06365ec6ced517bf2597fa1b7562060e1181, reversing</span><br><span class="line">changes made to 0ffc72ff1095bb8c70e72f39ab99e8102ce480b9.</span><br><span class="line"></span><br><span class="line"> Please enter the commit message <span class="keyword">for</span> your changes. Lines starting</span><br><span class="line"> with <span class="string">'#'</span> will be ignored, and an empty message aborts the commit.</span><br><span class="line"> </span><br><span class="line"> On branch master</span><br><span class="line"> Changes to be committed:</span><br><span class="line">       deleted:    file3</span><br><span class="line">       deleted:    file4</span><br></pre></td></tr></table></figure><p>:wq 退出看到:<br><img src="https://img-blog.csdnimg.cn/2020012115160522.png" alt="在这里插入图片描述"><br>file3 和 file4 是dev上的 commit 引入的文件，被正确地删掉了。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><ul><li>对于单一 parent 的 commit，直接使用 git revert commit_id;</li><li>对于具有多个 parent 的 commit，需要结合 -m 属性：git revert commit_id -m parent_id;</li><li>对于从 branch 合并到 master 的 merge commit，master 的 parent_id 是1，branch 的 parent_id 是2, 反之亦然;</li></ul><p>参考以下文章<br><a href="https://juejin.im/post/5acf4db8f265da239148822d" target="_blank" rel="noopener">当你决定去 revert 一个merge commit</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;在实际的开发工作中，使用git总会遇到一堆问题，本文将结合具体例子，讲述在何种条件下会出发&lt;strong&gt;git revert失败&lt;/str
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android沉浸式状态栏</title>
    <link href="https://ruanyandong.github.io/2020/02/16/Android%E6%B2%89%E6%B5%B8%E5%BC%8F%E7%8A%B6%E6%80%81%E6%A0%8F/"/>
    <id>https://ruanyandong.github.io/2020/02/16/Android沉浸式状态栏/</id>
    <published>2020-02-16T15:08:22.000Z</published>
    <updated>2020-02-16T15:10:14.980Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>之前做过Android沉浸式状态栏的相关需求，但是一直忙于工作，没时间系统的整理下沉浸式相关的知识，所以今天抽出时间，写一篇 Android沉浸式状态栏的文章。</p><h1 id="何为沉浸式"><a href="#何为沉浸式" class="headerlink" title="何为沉浸式"></a>何为沉浸式</h1><p><strong>沉浸式</strong>就是要给用户提供完全沉浸的体验，使用户有一种置身于虚拟世界之中的感觉。<br><strong>沉浸式模式</strong>就是整个屏幕中显示都是应用的内容，没有状态栏也没有导航栏，用户不会被一些系统的界面元素所打扰。<br><strong>Android沉浸式模式</strong>的本质就是全屏化，但这可能并不是我们想要的，我们还是来实现下网上传的沸沸扬扬的<strong>Android沉浸式状态栏</strong></p><h1 id="沉浸式状态栏的兼容情况"><a href="#沉浸式状态栏的兼容情况" class="headerlink" title="沉浸式状态栏的兼容情况"></a>沉浸式状态栏的兼容情况</h1><table><thead><tr><th>Android版本</th><th>透明状态栏</th></tr></thead><tbody><tr><td>&lt;4.4</td><td>×</td></tr><tr><td>4.4-5.0</td><td>✓</td></tr><tr><td>&gt;=5.0</td><td>✓</td></tr></tbody></table><table><thead><tr><th>Android版本</th><th>黑白字符状态栏</th></tr></thead><tbody><tr><td>&lt;6.0</td><td>×</td></tr><tr><td>&gt;=6.0</td><td>✓</td></tr></tbody></table><h1 id="fitsSystemWindows"><a href="#fitsSystemWindows" class="headerlink" title="fitsSystemWindows"></a>fitsSystemWindows</h1><p>在讲沉浸式状态栏之前，我们先来认识一个属性——fitsSystemWindows，这个属性在沉浸式状态中扮演着非常重要的角色。</p><ul><li>官方描述</li></ul><blockquote><p>Boolean internal attribute to adjust view layout based on system<br>windows such as the status bar. If true, adjusts the padding of this view to leave space for the system windows. Will only take effect if this view is in a non-embedded activity.</p></blockquote><ul><li>中文描述</li></ul><blockquote><p>Boolean内部属性是基于系统窗口（如status bar）调整视图布局。如果为true，将调整视图padding为系统窗口预留出空间。Will only take effect if this view is in a non-embedded activity.<br> 这句话的意思是view不在非嵌入式的activity才会生效。<br> 嵌入式activity是托管在父activity中的活动。常见的例子是TabHost / TabActivity设计。特别是，嵌入式Acitvities位于主机中 LocalActivityManager，这在概念上类似于 FragmentManager 它允许您在另一个内部显示一个Activity。</p></blockquote><p>根据这个定义，很容易理解为什么只有主机（非嵌入式）Activity才能支持 fitsSystemWindows 属性，因为任何嵌入的活动都限制在其主机定义的区域内。</p><ul><li>注意：<blockquote><p>fitsSystemWindows只作用在sdk&gt;=19的系统上就是高于4.4的系统，android:fitsSystemWindows默认值为false，并且在哪个控件设置android:fitsSystemWindows=”true”会有不一样的效果</p></blockquote></li></ul><p>android:fitsSystemWindows=”true”，这个属性可以给任何view设置,只要设置了这个属性此view的所有padding属性失效.只有在设置了透明状态栏(StatusBar)或者导航栏(NavigationBar)此属性才会生效</p><p><strong>当设置了透明状态栏(StatusBar)时:</strong><br>当为此activity设置了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;item name="android:windowTranslucentStatus"&gt;true&lt;/item&gt;</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">   getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果有以上两种情况之一,我们的状态栏(StatusBar)就会变成透明,并且布局会扩展到StatusBar的位置同时,所有设置了android:fitsSystemWindows=”true”属性的view会自动添加一个值等于状态栏高度的paddingTop</p><p><strong>当设置了透明导航栏(NavigationBar)时:</strong><br>当为此activity设置了:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;item name="android:windowTranslucentNavigation"&gt;true&lt;/item&gt;</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">    getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果有以上两种情况之一,我们的导航栏(NavigationBar)就会变成透明,并且布局会扩展到NavigationBar的位置。同时,所有设置了android:fitsSystemWindows=”true”属性的view会自动添加一个值等于导航栏高度的paddingBottom。</p><h1 id="沉浸式状态栏实现的一般思路"><a href="#沉浸式状态栏实现的一般思路" class="headerlink" title="沉浸式状态栏实现的一般思路"></a>沉浸式状态栏实现的一般思路</h1><ul><li><strong>4.4以下版本：</strong> 我们可以对StatusBar和 NavigationBar进行显示和隐藏操作，但无法实现沉浸式状态栏。</li><li><p><strong>Android4.4（API 19） - Android 5.0（API 21)：</strong> 通过FLAG_TRANSLUCENT_STATUS设置状态栏为透明并且为全屏模式，然后通过添加一个与StatusBar 一样大小的View，将View 的 background 设置为我们想要的颜色，从而来实现沉浸式。</p></li><li><p><strong>Android 5.0（API 21）以上版本：</strong> 在Android 5.0的时候，加入了一个重要的属性和方法 android:statusBarColor （对应方法为 setStatusBarColor），通过这个方法我们就可以轻松实现沉浸式。也就是说，从Android5.0开始，系统才真正的支持沉浸式。</p></li><li><p><strong>Android 6.0（API 23）以上版本：</strong> Android6.0以上的实现方式和Android 5.0 +是一样，但从Android 6.0（API 23）开始，我们可以改状态栏的绘制模式，可以显示白色或浅黑色的内容和图标（除了魅族手机，魅族自家有做源码更改，6.0以下就能实现）</p></li></ul><h3 id="Android4-4（API-19）-Android-5-0（API-21）实现沉浸式的方式"><a href="#Android4-4（API-19）-Android-5-0（API-21）实现沉浸式的方式" class="headerlink" title="Android4.4（API 19） - Android 5.0（API 21）实现沉浸式的方式"></a>Android4.4（API 19） - Android 5.0（API 21）实现沉浸式的方式</h3><p>Android 4.4 为什么能够实现沉浸式的效果呢？因为在Android 4.4 新增了一个重要的属性：<strong>FLAG_TRANSLUCENT_STATUS</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Window flag: request a translucent status bar with minimal system-provided</span></span><br><span class="line"><span class="comment">        * background protection.</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * &lt;p&gt;This flag can be controlled in your theme through the</span></span><br><span class="line"><span class="comment">        * &#123;<span class="doctag">@link</span> android.R.attr#windowTranslucentStatus&#125; attribute; this attribute</span></span><br><span class="line"><span class="comment">        * is automatically set for you in the standard translucent decor themes</span></span><br><span class="line"><span class="comment">        * such as</span></span><br><span class="line"><span class="comment">        * &#123;<span class="doctag">@link</span> android.R.style#Theme_Holo_NoActionBar_TranslucentDecor&#125;,</span></span><br><span class="line"><span class="comment">        * &#123;<span class="doctag">@link</span> android.R.style#Theme_Holo_Light_NoActionBar_TranslucentDecor&#125;,</span></span><br><span class="line"><span class="comment">        * &#123;<span class="doctag">@link</span> android.R.style#Theme_DeviceDefault_NoActionBar_TranslucentDecor&#125;, and</span></span><br><span class="line"><span class="comment">        * &#123;<span class="doctag">@link</span> android.R.style#Theme_DeviceDefault_Light_NoActionBar_TranslucentDecor&#125;.&lt;/p&gt;</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * &lt;p&gt;When this flag is enabled for a window, it automatically sets</span></span><br><span class="line"><span class="comment">        * the system UI visibility flags &#123;<span class="doctag">@link</span> View#SYSTEM_UI_FLAG_LAYOUT_STABLE&#125; and</span></span><br><span class="line"><span class="comment">        * &#123;<span class="doctag">@link</span> View#SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN&#125;.&lt;/p&gt;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_TRANSLUCENT_STATUS = <span class="number">0x04000000</span>;</span><br></pre></td></tr></table></figure></p><blockquote><p> 解释：设置状态栏透明，并且变为全屏模式。上面的解释已经说得很清楚了，当window的这个属性有效的时候，会自动设置 system ui visibility的标志SYSTEM_UI_FLAG_LAYOUT_STABLE和SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN.</p></blockquote><p><strong>有两种方式实现这个属性：</strong></p><p><strong>可以在代码中设置</strong>，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);</span><br></pre></td></tr></table></figure><p><strong>当然也可以在theme 中设置属性windowTranslucentStatus</strong>,如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:windowTranslucentStatus</span><br></pre></td></tr></table></figure></p><p>效果如下：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy84LzgvMTgzMDA4MzVmZGU4NzExOThlMzkwZTU5NWIwYTRkNzI?x-oss-process=image/format,png#pic_center" alt="Alt"><br>效果如上图，可以看出，沉浸式的效果是出来了，但是也有一个问题，<strong>我们的标题栏和状态栏重叠了</strong>，相当于整个布局上移了StatusBar 的高度。<strong>为了让标题栏回到原来的位置，我们在标题栏的上方添加一个大小和StatusBar大小一样的View,View 的BackgroundColor 为标题栏一样的颜色，这个View起到一个占位的作用。这个时候，标题栏就会下移StatusBar的高度，回到正常的位置。</strong><br>添加如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取windowphone下的decorView</span></span><br><span class="line"> ViewGroup decorView = (ViewGroup) activity.getWindow().getDecorView();</span><br><span class="line"> <span class="keyword">int</span>       count     = decorView.getChildCount();</span><br><span class="line"> <span class="comment">//判断是否已经添加了statusBarView</span></span><br><span class="line"> <span class="keyword">if</span> (count &gt; <span class="number">0</span> &amp;&amp; decorView.getChildAt(count - <span class="number">1</span>) <span class="keyword">instanceof</span> StatusBarView) &#123;</span><br><span class="line">     decorView.getChildAt(count - <span class="number">1</span>).setBackgroundColor(calculateStatusColor(color, statusBarAlpha));</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">//新建一个和状态栏高宽的view</span></span><br><span class="line">     StatusBarView statusView = createStatusBarView(activity, color, statusBarAlpha);</span><br><span class="line">     decorView.addView(statusView);</span><br><span class="line"> &#125;</span><br><span class="line"> ViewGroup rootView = (ViewGroup) ((ViewGroup) activity.findViewById(android.R.id.content)).getChildAt(<span class="number">0</span>);</span><br><span class="line"> <span class="comment">//rootview不会为状态栏留出状态栏空间</span></span><br><span class="line"> ViewCompat.setFitsSystemWindows(rootView,<span class="keyword">true</span>);</span><br><span class="line"> rootView.setClipToPadding(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>创建和status bar 一样大小的View的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> StatusBarView <span class="title">createStatusBarView</span><span class="params">(Activity activity, <span class="keyword">int</span> color, <span class="keyword">int</span> alpha)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 绘制一个和状态栏一样高的矩形</span></span><br><span class="line">       StatusBarView statusBarView = <span class="keyword">new</span> StatusBarView(activity);</span><br><span class="line">       LinearLayout.LayoutParams params =</span><br><span class="line">               <span class="keyword">new</span> LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, getStatusBarHeight(activity));</span><br><span class="line">       statusBarView.setLayoutParams(params);</span><br><span class="line">       statusBarView.setBackgroundColor(calculateStatusColor(color, alpha));</span><br><span class="line">       <span class="keyword">return</span> statusBarView;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>其中StatusBarView 就是一个普通的View。<br>添加上述代码后，效果如下：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy84LzgvNjFkNjhmZThjMTkzOGZhNGFkMjEwMjgzZTU0ODRhY2Y?x-oss-process=image/format,png#pic_center" alt="Alt"><br>通过以上就可以实现<strong>Android 4.4 上的沉浸式状态栏</strong>。</p><p>另外，<strong>如果是一张图片延伸到状态栏的话</strong>，直接设置<strong>FLAG_TRANSLUCENT_STATUS</strong>就可以了，如下：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy84LzgvZmY2Y2M4MmZiZDhhZTVjZjk2OTkyNjI4OWM4ZTQ1YWQ?x-oss-process=image/format,png#pic_center" alt="Alt"></p><blockquote><p>小结：Android4.4上实现沉浸式状态栏的套路是：为window添加FLAG_TRANSLUCENT_STATUS Flag,然后添加一个和status bar 一样大小的View 站位，从而让让标题栏不会与status bar重叠。而图片延伸到状态栏只需要设置FLAG_TRANSLUCENT_STATUS就OK。</p></blockquote><p> 沉浸式在Android4.4 - Android5.0 之间的版本表现得不是很好，从上面贴的几张图就可以看出，状态栏的顶部有一个渐变，会显示出黑色的阴影（底部的导航栏也是一样的效果），在Android 5.0 版本已经被修复了。</p><h3 id="Android-5-0（API-21）以上实现沉浸式的方式"><a href="#Android-5-0（API-21）以上实现沉浸式的方式" class="headerlink" title="Android 5.0（API 21）以上实现沉浸式的方式"></a>Android 5.0（API 21）以上实现沉浸式的方式</h3><p> Android 5.0 是一个里程碑式的版本，从Android 5.0开始，Google 推出了全新的设计规范 Material Design,并且原生控件就可以实现一些炫酷的UI动效。从这个版本开始，google 加入了一个比较重要的方法setStatusBarColor (对应属性：android:statusBarColor),通过这个方法，可以很轻松地实现沉浸式状态栏。方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Sets the color of the status bar to &#123;<span class="doctag">@code</span> color&#125;.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * For this to take effect,</span></span><br><span class="line"><span class="comment">    * the window must be drawing the system bar backgrounds with</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> android.view.WindowManager.LayoutParams#FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS&#125; and</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> android.view.WindowManager.LayoutParams#FLAG_TRANSLUCENT_STATUS&#125; must not be set.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * If &#123;<span class="doctag">@code</span> color&#125; is not opaque, consider setting</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> android.view.View#SYSTEM_UI_FLAG_LAYOUT_STABLE&#125; and</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> android.view.View#SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN&#125;.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * The transitionName for the view background will be "android:status:background".</span></span><br><span class="line"><span class="comment">    * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setStatusBarColor</span><span class="params">(@ColorInt <span class="keyword">int</span> color)</span></span>;</span><br></pre></td></tr></table></figure><p>注意看这个方法的注释，<strong>想要这个方法生效，必须还要配合一个Flag一起使用，必须设置FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS ,并且不能设置FLAG_TRANSLUCENT_STATUS(Android 4.4才用这个)</strong><br>看一下<strong>FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS</strong>这个flag:<br>可以看到，这个flag 也是在Android 5.0添加的，它的作用是什么呢？</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy84LzgvZDBkZDkwYjQxMDE5MDdlNGM0Mjk5MzMzMjcxY2ExODc?x-oss-process=image/format,png#pic_center" alt="Alt"></p><blockquote><p>解释：设置了FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS,表明会Window负责系统bar的background 绘制，绘制透明背景的系统bar（状态栏和导航栏），然后用getStatusBarColor()和getNavigationBarColor()的颜色填充相应的区域。这就是Android 5.0 以上实现沉浸式导航栏的原理。</p></blockquote><p>实现沉浸式添加如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getWindow().addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);</span><br><span class="line"><span class="comment">//注意要清除 FLAG_TRANSLUCENT_STATUS flag</span></span><br><span class="line">getWindow().clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);</span><br><span class="line">getWindow().setStatusBarColor(getResources().getColor(android.R.color.holo_red_light));</span><br></pre></td></tr></table></figure></p><p>效果如下：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy84LzgvM2U1NmU0ZThkMWM2NDlhOTJmNWNjMTYyYWI5MjhkMzM?x-oss-process=image/format,png#pic_center" alt="Alt"></p><p>当然也可以直接在Theme中使用，在values-v21文件夹下添加如下主题：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name=<span class="string">"MDTheme"</span> parent=<span class="string">"Theme.Design.Light.NoActionBar"</span>&gt;</span><br><span class="line">        &lt;item name="android:windowTranslucentStatus"&gt;false&lt;/item&gt;</span><br><span class="line">        &lt;item name="android:windowDrawsSystemBarBackgrounds"&gt;true&lt;/item&gt;</span><br><span class="line">        &lt;item name="android:statusBarColor"&gt;@android:color/holo_red_light&lt;/item&gt;</span><br><span class="line">    &lt;/style&gt;</span><br></pre></td></tr></table></figure><p>效果和上面代码中添加的效果一样。</p><p><strong>图片延伸到状态栏</strong></p><p>在<strong>Android 5.0使图片延伸到状态栏</strong>，只需设置windowTranslucentStatus,将 statusBarColor 设置为透明即可：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name=<span class="string">"ImageTranslucentTheme"</span> parent=<span class="string">"Theme.AppCompat.DayNight.NoActionBar"</span>&gt;</span><br><span class="line">        &lt;item name="android:windowTranslucentNavigation"&gt;true&lt;/item&gt;</span><br><span class="line">        &lt;item name="android:windowTranslucentStatus"&gt;true&lt;/item&gt;</span><br><span class="line">        &lt;!-- 设置statusBarColor 为透明--&gt;</span><br><span class="line">        &lt;item name="android:statusBarColor"&gt;@android:color/transparent&lt;/item&gt;</span><br><span class="line">    &lt;/style&gt;</span><br></pre></td></tr></table></figure><p>效果如下：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy84LzgvY2JiMjYxODFhNGNlNTA1NDdiYWIxMGQ5ZDE0MWNiOGE?x-oss-process=image/format,png#pic_center" alt="Alt"></p><p>代码实现方式中通过版本号的判断兼容 Android5.0以下和Android 5.0以上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">            activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);</span><br><span class="line">            activity.getWindow().clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);</span><br><span class="line">            activity.getWindow().setStatusBarColor(calculateStatusColor(color, statusBarAlpha));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">            activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);</span><br><span class="line">            ViewGroup decorView = (ViewGroup) activity.getWindow().getDecorView();</span><br><span class="line">            <span class="keyword">int</span> count = decorView.getChildCount();</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span> &amp;&amp; decorView.getChildAt(count - <span class="number">1</span>) <span class="keyword">instanceof</span> StatusBarView) &#123;</span><br><span class="line">                decorView.getChildAt(count - <span class="number">1</span>).setBackgroundColor(calculateStatusColor(color, statusBarAlpha));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                StatusBarView statusView = createStatusBarView(activity, color, statusBarAlpha);</span><br><span class="line">                decorView.addView(statusView);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ViewGroup rootView = (ViewGroup) ((ViewGroup) activity.findViewById(android.R.id.content)).getChildAt(<span class="number">0</span>);</span><br><span class="line">            rootView.setFitsSystemWindows(<span class="keyword">true</span>);</span><br><span class="line">            rootView.setClipToPadding(<span class="keyword">true</span>);</span><br><span class="line">            setRootView(activity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Android-6-0-实现状态栏字色和图标浅黑色"><a href="#Android-6-0-实现状态栏字色和图标浅黑色" class="headerlink" title="Android 6.0 + 实现状态栏字色和图标浅黑色"></a>Android 6.0 + 实现状态栏字色和图标浅黑色</h3><p>使用沉浸式的时候会遇到一个问题，那就是<strong>Android 系统状态栏的字色和图标颜色为白色，当我的主题色或者图片接近白色或者为浅色的时候，状态栏上的内容就看不清了</strong>。 这个问题在Android 6.0的时候得到了解决。<strong>Android 6.0 新添加了一个属性SYSTEM_UI_FLAG_LIGHT_STATUS_BAR</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy84LzgvZjIyZDkwOWU5ZjMwMTkzODBhODhmYzNhNDRlZWRiMzc?x-oss-process=image/format,png#pic_center" alt="Alt"></p><blockquote><p>解释：为setSystemUiVisibility(int)方法添加的Flag,请求status bar<br>绘制模式，它可以兼容亮色背景的status bar 。要在设置了FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDSflag<br>,同时清除了FLAG_TRANSLUCENT_STATUSflag 才会生效。</p></blockquote><p>添加如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;</span><br><span class="line">            getWindow().getDecorView().setSystemUiVisibility(</span><br><span class="line">                    View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN|View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>效果如下：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy84LzgvOTA3MGM3NTc3Y2YxYmQwNjM5MDUwNGM5NTRmMzE4NjU?x-oss-process=image/format,png#pic_center" alt="Alt"><br>除了在代码中添加以外，还可以直接在主题中使用属性：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name=<span class="string">"MDTheme"</span> parent=<span class="string">"Theme.Design.Light.NoActionBar"</span>&gt;</span><br><span class="line">       &lt;item name="android:windowTranslucentStatus"&gt;false&lt;/item&gt;</span><br><span class="line">       &lt;item name="android:windowDrawsSystemBarBackgrounds"&gt;true&lt;/item&gt;</span><br><span class="line">       &lt;item name="android:statusBarColor"&gt;@android:color/holo_red_light&lt;/item&gt;</span><br><span class="line">       &lt;!-- Android <span class="number">6.0</span>以上 状态栏字色和图标为浅黑色--&gt;</span><br><span class="line">       &lt;item name="android:windowLightStatusBar"&gt;true&lt;/item&gt;</span><br><span class="line">   &lt;/style&gt;</span><br></pre></td></tr></table></figure><p>注意：主题要放在values-v23文件夹下</p><p><strong>参考以下文章</strong><br><a href="https://juejin.im/post/5989ded56fb9a03c3b6c8bde" target="_blank" rel="noopener">Android关于沉浸式状态栏总结</a><br><a href="https://juejin.im/post/5b7d40a4f265da432a6adca5" target="_blank" rel="noopener">Android适配—沉浸式状态栏</a><br><a href="https://jaeger.itscoder.com/android/2016/02/15/status-bar-demo.html" target="_blank" rel="noopener">Android App 沉浸式状态栏解决方案</a><br><a href="https://www.infoq.cn/article/PaCj30OK19ubiSbdrbHG" target="_blank" rel="noopener">Android 沉浸式解析和轮子使用</a><br><a href="https://www.jianshu.com/p/a44c119d6ef7" target="_blank" rel="noopener">Android沉浸式(透明)状态栏适配</a><br><a href="https://blog.csdn.net/guolin_blog/article/details/51763825" target="_blank" rel="noopener">Android状态栏微技巧，带你真正理解沉浸式模式</a><br><a href="https://segmentfault.com/a/1190000017431435" target="_blank" rel="noopener">android沉浸式状态栏封装—教你玩出新花样</a><br><a href="https://github.com/gyf-dev/ImmersionBar" target="_blank" rel="noopener">ImmersionBar – android 4.4以上沉浸式实现</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;之前做过Android沉浸式状态栏的相关需求，但是一直忙于工作，没时间系统的整理下沉浸式相关的知识，所以今天抽出时间，写一篇 Android
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java守护线程和非守护线程</title>
    <link href="https://ruanyandong.github.io/2019/06/17/Java%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E5%92%8C%E9%9D%9E%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B/"/>
    <id>https://ruanyandong.github.io/2019/06/17/Java守护线程和非守护线程/</id>
    <published>2019-06-16T16:24:36.000Z</published>
    <updated>2019-06-16T16:26:34.022Z</updated>
    
    <content type="html"><![CDATA[<p>请参考&gt;&gt;<a href="https://blog.csdn.net/lc1010078424/article/details/79613348" target="_blank" rel="noopener">Java守护线程和非守护线程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;请参考&amp;gt;&amp;gt;&lt;a href=&quot;https://blog.csdn.net/lc1010078424/article/details/79613348&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java守护线程和非守护线程&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>代码库上传Jcenter</title>
    <link href="https://ruanyandong.github.io/2019/06/16/%E4%BB%A3%E7%A0%81%E5%BA%93%E4%B8%8A%E4%BC%A0Jcenter/"/>
    <id>https://ruanyandong.github.io/2019/06/16/代码库上传Jcenter/</id>
    <published>2019-06-16T03:03:22.000Z</published>
    <updated>2019-06-16T03:09:23.134Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/lmj623565791/article/details/51148825" target="_blank" rel="noopener">Android 快速发布开源项目到jcenter</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/lmj623565791/article/details/51148825&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android 快速发布开源项目到jcenter&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android网络安全配置</title>
    <link href="https://ruanyandong.github.io/2019/06/11/Android%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE/"/>
    <id>https://ruanyandong.github.io/2019/06/11/Android网络安全配置/</id>
    <published>2019-06-11T03:53:49.000Z</published>
    <updated>2019-06-11T04:03:51.380Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/dcfb61720413" target="_blank" rel="noopener">请看这篇文章——Android网络安全配置</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/dcfb61720413&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;请看这篇文章——Android网络安全配置&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java值传递和引用传递</title>
    <link href="https://ruanyandong.github.io/2019/04/24/java%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/"/>
    <id>https://ruanyandong.github.io/2019/04/24/java值传递和引用传递/</id>
    <published>2019-04-24T13:30:34.000Z</published>
    <updated>2019-04-24T13:38:03.858Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java在传参时分为值-传递-和-引用传递-。参数为基本类型时是值传递，-参数为封装类型时是引用传递。"><a href="#java在传参时分为值-传递-和-引用传递-。参数为基本类型时是值传递，-参数为封装类型时是引用传递。" class="headerlink" title="java在传参时分为值 传递 和 引用传递 。参数为基本类型时是值传递， 参数为封装类型时是引用传递。"></a>java在传参时分为值 传递 和 引用传递 。参数为基本类型时是值传递， 参数为封装类型时是引用传递。</h1><h2 id="基本类型参数"><a href="#基本类型参数" class="headerlink" title="基本类型参数"></a>基本类型参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int num = 0 ;</span><br><span class="line">        changeNum(num);</span><br><span class="line">        System.out.println(&quot;num=&quot;+num);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private static void changeNum(int num) &#123;</span><br><span class="line">        num = 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印的结果是num=0。</p><h2 id="封装类型参数"><a href="#封装类型参数" class="headerlink" title="封装类型参数"></a>封装类型参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Product p = new Product();</span><br><span class="line">        p.setProName(&quot;before&quot;);</span><br><span class="line">        p.setNum(0);</span><br><span class="line">        changeProduct(p);</span><br><span class="line">        System.out.println(&quot;p.proName=&quot;+p.getProName());</span><br><span class="line">        System.out.println(&quot;p.num=&quot;+p.getNum());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private static void changeProduct(Product p) &#123;</span><br><span class="line">        p.setProName(&quot;after&quot;);</span><br><span class="line">        p.setNum(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class Product &#123;</span><br><span class="line">    private int num;</span><br><span class="line">    private String proName;</span><br><span class="line"> </span><br><span class="line">    public int getNum() &#123;</span><br><span class="line">        return num;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setNum(int num) &#123;</span><br><span class="line">        this.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public String getProName() &#123;</span><br><span class="line">        return proName;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setProName(String proName) &#123;</span><br><span class="line">        this.proName = proName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行的结果是：p.proName=after和p.num=1 。</p><h2 id="上面的两个例子是明显的值传递和引用传递。但是如果参数是String类型呢？"><a href="#上面的两个例子是明显的值传递和引用传递。但是如果参数是String类型呢？" class="headerlink" title="上面的两个例子是明显的值传递和引用传递。但是如果参数是String类型呢？"></a>上面的两个例子是明显的值传递和引用传递。但是如果参数是String类型呢？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String str = &quot;ab&quot;;</span><br><span class="line">        changeString(str);</span><br><span class="line">        System.out.println(&quot;str=&quot;+str);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private static void changeString(String str) &#123;</span><br><span class="line">        str = &quot;cd&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照前面的例子，String应该是一个封装类型，它应该是引用传递，是可以改变值得， 运行的结果应该是”cd”。<br>我们实际运行一下看看，str=ab,这如何解释呢？</p><h2 id="这就要从java底层的机制讲起了，java的内存模型分为-堆-和-栈-。"><a href="#这就要从java底层的机制讲起了，java的内存模型分为-堆-和-栈-。" class="headerlink" title="这就要从java底层的机制讲起了，java的内存模型分为 堆 和 栈 。"></a>这就要从java底层的机制讲起了，java的内存模型分为 堆 和 栈 。</h2><p>1.基本类型的变量放在栈里；<br>2.封装类型中，对象放在堆里，对象的引用放在栈里。</p><p>java在方法传递参数时，是将变量复制一份，然后传入方法体去执行。 这句话是很难理解的，也是解释这个 问题的精髓。我们先按照这句话解释一下基本类型的传递</p><pre><code>虚拟机分配给num一个内存地址，并且存了一个值0.虚拟机复制了一个num，我们叫他num’，num’和num的内存地址不同，但存的值都是0。虚拟机讲num’传入方法，方法将num’的值改为1.方法结束，方法外打印num的值，由于num内存中的值没有改变，还是0，所以打印是0.</code></pre><p>我们再解释封装类型的传递：</p><pre><code>虚拟机在堆中开辟了一个Product的内存空间，内存中包含proName和num。虚拟机在栈中分配给p一个内存地址，这个地址中存的是1中的Product的内存地址。虚拟机复制了一个p，我们叫他p’,p和p’的内存地址不同，但它们存的值是相同的，都是1中Product的内存地址。将p’传入方法，方法改变了1中的proName和num。方法结束，方法外打印p中变量的值，由于p和p’中存的都是1中Product的地址，但是1中Product里的值发生了改变， 所以，方法外打印p的值，是方法执行以后的。我们看到的效果是封装类型的值是改变的。</code></pre><p>最后我们再来解释String在传递过程中的步骤：</p><pre><code>虚拟机在堆中开辟一块内存，并存值”ab”。虚拟机在栈中分配给str一个内存，内存中存的是1中的地址。虚拟机复制一份str，我们叫str’，str和str’内存不同，但存的值都是1的地址。将str’传入方法体方法体在堆中开辟一块内存，并存值”cd”方法体将str’的值改变，存入5的内存地址方法结束，方法外打印str，由于str存的是1的地址，所有打印结果是”ab”</code></pre><p>这样我们理解了java在方法传参的整个过程。其实还是上面那句比较重要的话 java在方法传递参数时，是将变量复制一份，然后传入方法体去执行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java在传参时分为值-传递-和-引用传递-。参数为基本类型时是值传递，-参数为封装类型时是引用传递。&quot;&gt;&lt;a href=&quot;#java在传参时分为值-传递-和-引用传递-。参数为基本类型时是值传递，-参数为封装类型时是引用传递。&quot; class=&quot;headerlin
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android NDK学习</title>
    <link href="https://ruanyandong.github.io/2019/03/30/Android-NDK%E5%AD%A6%E4%B9%A0/"/>
    <id>https://ruanyandong.github.io/2019/03/30/Android-NDK学习/</id>
    <published>2019-03-29T18:52:50.000Z</published>
    <updated>2019-03-29T18:58:25.093Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://developer.android.google.cn/ndk/guides/android_mk" target="_blank" rel="noopener">Android NDK官网</a><br><a href="https://www.jianshu.com/p/87ce6f565d37" target="_blank" rel="noopener">Android JNI</a><br><a href="https://blog.csdn.net/young_time/article/details/80346631" target="_blank" rel="noopener">使用 Android Studio 写出第一个 NDK 程序</a><br><a href="https://www.jianshu.com/c/a25bf14495d7" target="_blank" rel="noopener">Android NDK 开发之旅</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://developer.android.google.cn/ndk/guides/android_mk&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android NDK官网&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>android音视频学习</title>
    <link href="https://ruanyandong.github.io/2019/03/12/android%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0/"/>
    <id>https://ruanyandong.github.io/2019/03/12/android音视频学习/</id>
    <published>2019-03-12T06:32:54.000Z</published>
    <updated>2019-03-12T07:05:04.150Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/renhui/p/7452572.html" target="_blank" rel="noopener">android音视频学习</a><br><a href="https://blog.csdn.net/ywl5320/article/details/80335290" target="_blank" rel="noopener">Android音视频开发详解</a><br><a href="https://blog.csdn.net/eydwyz/article/details/79112260" target="_blank" rel="noopener">Android音视频开发进阶</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/renhui/p/7452572.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;android音视频学习&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CheckBox改变样式</title>
    <link href="https://ruanyandong.github.io/2019/03/12/CheckBox%E6%94%B9%E5%8F%98%E6%A0%B7%E5%BC%8F/"/>
    <id>https://ruanyandong.github.io/2019/03/12/CheckBox改变样式/</id>
    <published>2019-03-12T05:11:01.000Z</published>
    <updated>2019-03-12T05:19:27.176Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-自定义CheckBox样式"><a href="#Android-自定义CheckBox样式" class="headerlink" title="Android 自定义CheckBox样式"></a>Android 自定义CheckBox样式</h1><h2 id="一、修改checkbox选项框样式"><a href="#一、修改checkbox选项框样式" class="headerlink" title="一、修改checkbox选项框样式"></a>一、修改checkbox选项框样式</h2><h3 id="首先我们要找到两张checkbox选项框的图片："><a href="#首先我们要找到两张checkbox选项框的图片：" class="headerlink" title="首先我们要找到两张checkbox选项框的图片："></a>首先我们要找到两张checkbox选项框的图片：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">normal.png</span><br><span class="line"></span><br><span class="line">checked.png</span><br></pre></td></tr></table></figure><h3 id="然后我们设置一个背景选择器checkbox-style-xml："><a href="#然后我们设置一个背景选择器checkbox-style-xml：" class="headerlink" title="然后我们设置一个背景选择器checkbox_style.xml："></a>然后我们设置一个背景选择器checkbox_style.xml：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;item android:drawable=&quot;@drawable/checked&quot; android:state_checked=&quot;true&quot;/&gt;</span><br><span class="line">    &lt;item android:drawable=&quot;@drawable/normal&quot; android:state_checked=&quot;false&quot;/&gt;</span><br><span class="line">    &lt;item android:drawable=&quot;@drawable/normal&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/selector&gt;</span><br></pre></td></tr></table></figure><h3 id="到这里，在往下有两种方案，一种是直接在布局文件的android：button属性中设置："><a href="#到这里，在往下有两种方案，一种是直接在布局文件的android：button属性中设置：" class="headerlink" title="到这里，在往下有两种方案，一种是直接在布局文件的android：button属性中设置："></a>到这里，在往下有两种方案，一种是直接在布局文件的android：button属性中设置：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;CheckBox</span><br><span class="line">            android:id=&quot;@+id/checkbox1&quot;</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:text=&quot;@strings/check_text&quot;</span><br><span class="line">            android:button=&quot;@drawable/checkbox_style&quot;</span><br><span class="line">            android:checked=&quot;true&quot;/&gt;</span><br></pre></td></tr></table></figure><h3 id="还有一种是在style-xml文件中添加样式MyCheckboxStyle，并在布局文件中的style属性中设置："><a href="#还有一种是在style-xml文件中添加样式MyCheckboxStyle，并在布局文件中的style属性中设置：" class="headerlink" title="还有一种是在style.xml文件中添加样式MyCheckboxStyle，并在布局文件中的style属性中设置："></a>还有一种是在style.xml文件中添加样式MyCheckboxStyle，并在布局文件中的style属性中设置：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name=&quot;MyCheckboxStyle&quot; parent=&quot;@android:style/Widget.CompoundButton.CheckBox&quot;&gt;</span><br><span class="line">    &lt;item name=&quot;android:button&quot;&gt;@drawable/checkbox_style&lt;/item&gt;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;CheckBox</span><br><span class="line">        android:id=&quot;@+id/checkbox1&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        style=&quot;@style/MyCheckboxStyle&quot; /&gt;</span><br></pre></td></tr></table></figure><h2 id="二、去掉选项框，自定义类Button样式"><a href="#二、去掉选项框，自定义类Button样式" class="headerlink" title="二、去掉选项框，自定义类Button样式"></a>二、去掉选项框，自定义类Button样式</h2><h3 id="同样，我们需要来一个selector-checkbox-style-xml，但是这里的图片就不是选项框的图片了，而是整个checkbox的背景图片"><a href="#同样，我们需要来一个selector-checkbox-style-xml，但是这里的图片就不是选项框的图片了，而是整个checkbox的背景图片" class="headerlink" title="同样，我们需要来一个selector checkbox_style.xml，但是这里的图片就不是选项框的图片了，而是整个checkbox的背景图片"></a>同样，我们需要来一个selector checkbox_style.xml，但是这里的图片就不是选项框的图片了，而是整个checkbox的背景图片</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;item android:drawable=&quot;@drawable/checked&quot; android:state_checked=&quot;true&quot;/&gt;</span><br><span class="line">    &lt;item android:drawable=&quot;@drawable/normal&quot; android:state_checked=&quot;false&quot;/&gt;</span><br><span class="line">    &lt;item android:drawable=&quot;@drawable/normal&quot;/&gt;</span><br></pre></td></tr></table></figure><h3 id="然后，我们可以在布局文件中将android：button属性设置为“-null”来去掉选项框，并且在android：background属性中设置："><a href="#然后，我们可以在布局文件中将android：button属性设置为“-null”来去掉选项框，并且在android：background属性中设置：" class="headerlink" title="然后，我们可以在布局文件中将android：button属性设置为“@null”来去掉选项框，并且在android：background属性中设置："></a>然后，我们可以在布局文件中将android：button属性设置为“@null”来去掉选项框，并且在android：background属性中设置：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;CheckBox</span><br><span class="line">            android:id=&quot;@+id/checkbox1&quot;</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:background=&quot;@drawable/checkbox_style&quot;</span><br><span class="line">            android:button=&quot;@null&quot;</span><br><span class="line">            android:checked=&quot;true&quot;/&gt;</span><br></pre></td></tr></table></figure><h2 id="文章链接"><a href="#文章链接" class="headerlink" title="文章链接"></a>文章链接</h2><p><a href="https://www.cnblogs.com/lihualuo/p/3665847.html" target="_blank" rel="noopener">Android知识整理（3） 两种自定义样式的Checkbox</a><br><a href="https://www.cnblogs.com/Claire6649/p/5941145.html" target="_blank" rel="noopener">Android 自定义CheckBox样式</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Android-自定义CheckBox样式&quot;&gt;&lt;a href=&quot;#Android-自定义CheckBox样式&quot; class=&quot;headerlink&quot; title=&quot;Android 自定义CheckBox样式&quot;&gt;&lt;/a&gt;Android 自定义CheckBox样式&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JDBC学习</title>
    <link href="https://ruanyandong.github.io/2018/12/30/JDBC%E5%AD%A6%E4%B9%A0/"/>
    <id>https://ruanyandong.github.io/2018/12/30/JDBC学习/</id>
    <published>2018-12-30T10:00:44.000Z</published>
    <updated>2018-12-30T13:27:41.308Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDBC之存贮过程的调用"><a href="#JDBC之存贮过程的调用" class="headerlink" title="JDBC之存贮过程的调用"></a>JDBC之存贮过程的调用</h1><h2 id="存储过程的代码"><a href="#存储过程的代码" class="headerlink" title="存储过程的代码"></a>存储过程的代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE imooc_db.sp_select_nofilter()</span><br><span class="line">BEGIN</span><br><span class="line">     select * from imooc_goddess;</span><br><span class="line">END;</span><br><span class="line">imooc_db是数据库的名字，sp_select_nofilter()是存储过程的方法名；</span><br></pre></td></tr></table></figure><h2 id="调用代码"><a href="#调用代码" class="headerlink" title="调用代码"></a>调用代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Connection conn = DBUtil.getConnection();</span><br><span class="line">CallableStatement cs = conn.prepareCall(&quot;&#123;call sp_select_nofilter()&#125;&quot;);</span><br><span class="line">cs.execute();</span><br><span class="line">ResultSet rs = cd.getResultSet();</span><br></pre></td></tr></table></figure><h2 id="博客链接"><a href="#博客链接" class="headerlink" title="博客链接"></a>博客链接</h2><p>  <a href="https://www.cnblogs.com/Qian123/p/5349884.html" target="_blank" rel="noopener">JDBC慕课学习博客链接</a><br>  <a href="https://blog.csdn.net/wqc19920906/article/details/72825793" target="_blank" rel="noopener">Java 数据库系列教程–C3P0详解</a><br>  <a href="https://baike.baidu.com/item/c3p0" target="_blank" rel="noopener">c3p0配置</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JDBC之存贮过程的调用&quot;&gt;&lt;a href=&quot;#JDBC之存贮过程的调用&quot; class=&quot;headerlink&quot; title=&quot;JDBC之存贮过程的调用&quot;&gt;&lt;/a&gt;JDBC之存贮过程的调用&lt;/h1&gt;&lt;h2 id=&quot;存储过程的代码&quot;&gt;&lt;a href=&quot;#存储过程的代
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>DialogFragment的宽高设置</title>
    <link href="https://ruanyandong.github.io/2018/12/29/DialogFragment%E7%9A%84%E5%AE%BD%E9%AB%98%E8%AE%BE%E7%BD%AE/"/>
    <id>https://ruanyandong.github.io/2018/12/29/DialogFragment的宽高设置/</id>
    <published>2018-12-28T17:56:34.000Z</published>
    <updated>2018-12-28T18:02:50.069Z</updated>
    
    <content type="html"><![CDATA[<h1 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onResume() &#123;</span><br><span class="line">    ViewGroup.LayoutParams params = getDialog().getWindow().getAttributes();</span><br><span class="line">    params.width = LayoutParams.MATCH_PARENT;</span><br><span class="line">    params.height = LayoutParams.MATCH_PARENT;</span><br><span class="line">    getDialog().getWindow().setAttributes((android.view.WindowManager.LayoutParams) params);</span><br><span class="line"></span><br><span class="line">    super.onResume();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onResume() &#123;</span><br><span class="line">    getDialog().getWindow().setLayout(width, height);</span><br><span class="line">    super.onResume();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;方法一&quot;&gt;&lt;a href=&quot;#方法一&quot; class=&quot;headerlink&quot; title=&quot;方法一&quot;&gt;&lt;/a&gt;方法一&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;s
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android依赖管理与私服搭建</title>
    <link href="https://ruanyandong.github.io/2018/12/03/Android%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E4%B8%8E%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/"/>
    <id>https://ruanyandong.github.io/2018/12/03/Android依赖管理与私服搭建/</id>
    <published>2018-12-02T17:37:17.000Z</published>
    <updated>2018-12-03T13:18:52.762Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android引入依赖的多种方式"><a href="#Android引入依赖的多种方式" class="headerlink" title="Android引入依赖的多种方式"></a>Android引入依赖的多种方式</h1><h2 id="一、第三方jar包"><a href="#一、第三方jar包" class="headerlink" title="一、第三方jar包"></a>一、第三方jar包</h2><p>   步骤：将jar包放入libs目录下面，然后add as library</p><h2 id="二、依赖本地模块"><a href="#二、依赖本地模块" class="headerlink" title="二、依赖本地模块"></a>二、依赖本地模块</h2><p>   步骤：新建本地module或者library，然后用本地模块进行依赖，例如：implementation project(‘:mylibrary’)</p><h2 id="三、aar方式依赖本地模块"><a href="#三、aar方式依赖本地模块" class="headerlink" title="三、aar方式依赖本地模块"></a>三、aar方式依赖本地模块</h2><p>   步骤：新建本地module或者library，然后build或者rebuild整个project，<br>   然后在新建的module或者library的build目录下的output目录下的aar目录，将aar文件放入需要依赖的libs目录下面，<br>   然后在gradle中加入一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">repositories&#123;</span><br><span class="line">        flatDir&#123;</span><br><span class="line">            dirs &apos;libs&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">implementation(name:&apos;lib2&apos;,ext:&apos;aar&apos;)</span><br><span class="line">name是aar文件的名字，ext是后缀名</span><br></pre></td></tr></table></figure></p><h2 id="四、在相应的gradle文件依赖"><a href="#四、在相应的gradle文件依赖" class="headerlink" title="四、在相应的gradle文件依赖"></a>四、在相应的gradle文件依赖</h2><p>   步骤：直接在dependencies进行implementation<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如：implementation &apos;com.android.support:appcompat-v7:28.0.0&apos;</span><br></pre></td></tr></table></figure></p><h1 id="私服Nexus的获取和windows平台搭建"><a href="#私服Nexus的获取和windows平台搭建" class="headerlink" title="私服Nexus的获取和windows平台搭建"></a>私服Nexus的获取和windows平台搭建<img src="http://www.sonatype.com" alt="网址"></h1><p>  以下是一些参考博客</p><ul><li><a href="https://www.jianshu.com/p/b1fe26d5b8c8" target="_blank" rel="noopener">maven私服搭建及gradle上传</a>  </li><li><a href="https://blog.csdn.net/huweijian5/article/details/56670569" target="_blank" rel="noopener">Windows下搭建基于Nexus的Android Maven私服(一)</a></li><li><a href="https://blog.csdn.net/huweijian5/article/details/56834199" target="_blank" rel="noopener">Windows下搭建基于Nexus的Android Maven私服(二)</a></li><li><a href="https://www.jianshu.com/p/e8d999465edf" target="_blank" rel="noopener">Gradle中文教程系列-跟我学Gradle-4.1：Nexus私服的安装与配置</a></li><li><a href="https://blog.csdn.net/u011974987/article/details/52372185" target="_blank" rel="noopener">使用Gradle和Sonatype Nexus 搭建私有maven仓库</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Android引入依赖的多种方式&quot;&gt;&lt;a href=&quot;#Android引入依赖的多种方式&quot; class=&quot;headerlink&quot; title=&quot;Android引入依赖的多种方式&quot;&gt;&lt;/a&gt;Android引入依赖的多种方式&lt;/h1&gt;&lt;h2 id=&quot;一、第三方jar包
      
    
    </summary>
    
    
  </entry>
  
</feed>
